# 完整脚本案例库

## 📋 案例库概述

本案例库提供从**入门到高级**的完整GainLab Script示例，涵盖各种技术指标和实用工具，每个案例都包含完整代码、详细说明和使用指导，帮助开发者快速上手和深入掌握GainLab Script编程。

### 🎯 案例分级
- 🟢 **初级案例** - 单一方法应用，适合入门学习
- 🟡 **中级案例** - 多方法组合，具有实用价值  
- 🔴 **高级案例** - 复杂功能实现，展示高级技巧
- 🛠️ **工具案例** - 实用交易工具，可直接使用

### 📊 案例覆盖
- ✅ **全方法覆盖** - 涵盖I、S、F、D、O、U所有方法类型
- ✅ **实战导向** - 每个案例都具有实际应用价值
- ✅ **最佳实践** - 体现编程规范和优化技巧
- ✅ **错误处理** - 展示健壮的错误处理机制

## 🟢 初级案例

### 案例1：简单移动平均线
*难度：⭐ 入门级 | 方法：I、S、F、D、O*

```javascript
//@name=简单MA
//@title=Simple Moving Average 简单移动平均线
//@desc=## 简单移动平均线指标
//用于分析价格趋势的基础指标，平滑价格波动
//@position=main
//@version=1

// 输入参数定义
period = I.int(20, '周期', 1, 200, 1, '基础参数', 'MA计算周期')
source = I.select('close', SOURCE, '数据源', '计算数据源选择')
showMA = I.bool(true, '显示MA线', '是否显示移动平均线')

// 样式定义  
maStyle = S.line('#FF6600', 2, 'solid', showMA, '移动平均线样式')

// 计算移动平均
ma = F.ma(dataList, period, source)

// 绘制图形
if (showMA) {
    D.line(ma, maStyle)
}

// 输出设置
setPrecision('price')
O.tools('MA' + period, ma, maStyle)

// 当前值输出
const currentMA = ma[ma.length - 1]
const currentPrice = dataList[dataList.length - 1]?.close

if (currentMA !== null && currentPrice !== null) {
    O.print(`当前MA${period}: ${currentMA.toFixed(2)}`)
    O.print(`当前价格: ${currentPrice.toFixed(2)}`)
    O.print(`价格位置: ${currentPrice > currentMA ? '上方' : '下方'}`)
}
```

### 案例2：RSI震荡指标
*难度：⭐ 入门级 | 方法：I、S、F、D、O*

```javascript
//@name=RSI
//@title=Relative Strength Index 相对强弱指数
//@desc=## RSI相对强弱指数
//衡量价格变动速度和强度的震荡指标
//- RSI > 70: 超买区域，考虑卖出
//- RSI < 30: 超卖区域，考虑买入
//@position=vice
//@version=1

// 输入参数
rsiPeriod = I.int(14, 'RSI周期', 1, 50, 1, '基础参数', 'RSI计算周期')
overbought = I.int(70, '超买线', 50, 100, 1, '信号线', '超买阈值')
oversold = I.int(30, '超卖线', 0, 50, 1, '信号线', '超卖阈值')
showSignals = I.bool(true, '显示信号', '是否显示超买超卖信号')

// 样式定义
rsiStyle = S.line('#E91E63', 2, 'solid', title='RSI线')
obStyle = S.line('#FF4444', 1, 'dashed', title='超买线')
osStyle = S.line('#4CAF50', 1, 'dashed', title='超卖线')
centerStyle = S.line('#999999', 1, 'dotted', title='中线')

// 信号样式
buySignalStyle = S.shape('arrowUp', '#4CAF50', 12, 'value', 'fill', title='买入信号')
sellSignalStyle = S.shape('arrowDown', '#F44336', 12, 'value', 'fill', title='卖出信号')

// 计算RSI
rsiData = F.rsi(dataList, rsiPeriod)

// 信号检测
buySignals = rsiData.map(rsi => rsi !== null && rsi < oversold ? rsi : null)
sellSignals = rsiData.map(rsi => rsi !== null && rsi > overbought ? rsi : null)

// 绘制水平线
D.hline(overbought, obStyle)
D.hline(50, centerStyle)  
D.hline(oversold, osStyle)

// 绘制RSI线
D.line(rsiData, rsiStyle)

// 绘制信号
if (showSignals) {
    D.shape(buySignals, buySignalStyle)
    D.shape(sellSignals, sellSignalStyle)
}

// 副图设置
setMax(100)
setMin(0)
setPrecision(2)

// 输出
O.tools('RSI(' + rsiPeriod + ')', rsiData, rsiStyle)

// 当前状态分析
const currentRSI = rsiData[rsiData.length - 1]
if (currentRSI !== null) {
    let status = '中性'
    if (currentRSI > overbought) status = '超买'
    else if (currentRSI < oversold) status = '超卖'
    
    O.print(`当前RSI: ${currentRSI.toFixed(2)}`)
    O.print(`市场状态: ${status}`)
}
```

## 🟡 中级案例

### 案例3：双均线交叉系统
*难度：⭐⭐ 中级 | 方法：I、S、F、D、O、U*

```javascript
//@name=双均线交叉
//@title=Dual Moving Average Cross System 双均线交叉系统  
//@desc=## 双均线交叉系统
//基于快慢均线交叉的经典交易系统
//#### 交易信号：
//- **金叉**: 快线上穿慢线，买入信号
//- **死叉**: 快线下穿慢线，卖出信号
//#### 参数建议：
//- 短期: 5-20日，长期: 20-60日
//@position=main
//@version=1

// 基础参数组
fastPeriod = I.int(5, '快线周期', 1, 50, 1, '基础参数', '快速移动平均周期')
slowPeriod = I.int(20, '慢线周期', 5, 200, 1, '基础参数', '慢速移动平均周期')
source = I.select('close', SOURCE, '数据源', '基础参数', '计算数据源')

// 功能开关
showMA = I.bool(true, '显示均线', '显示控制', '是否显示移动平均线')
showSignals = I.bool(true, '显示信号', '显示控制', '是否显示交叉信号')
showFill = I.bool(false, '显示填充', '显示控制', '均线间填充区域')

// 高级参数
signalFilter = I.bool(false, '信号过滤', '高级设置', '启用信号过滤器')
minDistance = I.float(0.5, '最小距离%', 0.1, 5.0, 0.1, '高级设置', '信号触发最小距离百分比')

// 样式定义
fastStyle = S.line('#FF0000', 2, 'solid', showMA, '快线样式')
slowStyle = S.line('#0000FF', 2, 'solid', showMA, '慢线样式')
fillStyle = S.area('rgba(255, 0, 0, 0.1)', showFill, '填充样式')

// 信号样式
buyStyle = S.shape('arrowUp', '#00C851', 14, 'lowDown', 'fill', showSignals, '买入信号')
sellStyle = S.shape('arrowDown', '#FF4444', 14, 'highUp', 'fill', showSignals, '卖出信号')

// 计算均线
fastMA = F.ma(dataList, fastPeriod, source)
slowMA = F.ma(dataList, slowPeriod, source)

// 信号检测
rawBuySignals = F.throughUp(fastMA, slowMA)
rawSellSignals = F.throughDown(fastMA, slowMA)

// 信号过滤（如果启用）
let buySignals = rawBuySignals
let sellSignals = rawSellSignals

if (signalFilter) {
    buySignals = rawBuySignals.map((signal, index) => {
        if (signal === null) return null
        
        // 检查均线距离
        const fast = fastMA[index]
        const slow = slowMA[index]
        if (fast && slow) {
            const distance = Math.abs(fast - slow) / slow * 100
            return distance >= minDistance ? signal : null
        }
        return null
    })
    
    sellSignals = rawSellSignals.map((signal, index) => {
        if (signal === null) return null
        
        const fast = fastMA[index]
        const slow = slowMA[index]
        if (fast && slow) {
            const distance = Math.abs(fast - slow) / slow * 100
            return distance >= minDistance ? signal : null
        }
        return null
    })
}

// 绘制填充区域
if (showFill) {
    D.area(fastMA, slowMA, fillStyle)
}

// 绘制均线
if (showMA) {
    D.line(fastMA, fastStyle)
    D.line(slowMA, slowStyle)
}

// 绘制信号
if (showSignals) {
    D.shape(buySignals, buyStyle)
    D.shape(sellSignals, sellStyle)
}

// 输出设置
setPrecision('price')
O.tools('快线MA' + fastPeriod, fastMA, fastStyle)
O.tools('慢线MA' + slowPeriod, slowMA, slowStyle)

// 统计分析
if (U.isValid(buySignals) && U.isValid(sellSignals)) {
    const buyCount = U.filter(buySignals, s => s !== null).length
    const sellCount = U.filter(sellSignals, s => s !== null).length
    const totalSignals = buyCount + sellCount
    
    O.print(`=== 交叉信号统计 ===`)
    O.print(`金叉信号: ${buyCount}`)
    O.print(`死叉信号: ${sellCount}`)
    O.print(`总信号数: ${totalSignals}`)
    
    if (signalFilter) {
        const rawBuyCount = U.filter(rawBuySignals, s => s !== null).length
        const rawSellCount = U.filter(rawSellSignals, s => s !== null).length
        const filterRate = (1 - totalSignals / (rawBuyCount + rawSellCount)) * 100
        O.print(`信号过滤率: ${filterRate.toFixed(1)}%`)
    }
}

// 当前状态
const currentFast = fastMA[fastMA.length - 1]
const currentSlow = slowMA[slowMA.length - 1]
if (currentFast !== null && currentSlow !== null) {
    const trend = currentFast > currentSlow ? '多头' : '空头'
    const distance = Math.abs(currentFast - currentSlow) / currentSlow * 100
    
    O.print(`当前趋势: ${trend}`)
    O.print(`均线距离: ${distance.toFixed(2)}%`)
}
```

### 案例4：MACD多功能指标
*难度：⭐⭐ 中级 | 方法：I、S、F、D、O*

```javascript
//@name=MACD增强版
//@title=MACD Enhanced Version MACD增强版
//@desc=## MACD增强版指标
//Moving Average Convergence Divergence 异同移动平均线
//#### 组成部分：
//- **DIF线**: 快线EMA - 慢线EMA
//- **DEA线**: DIF的EMA平滑
//- **MACD柱**: (DIF - DEA) * 2
//#### 交易信号：
//- DIF上穿DEA: 金叉买入信号
//- DIF下穿DEA: 死叉卖出信号
//- MACD柱从负转正: 多头趋势确认
//@position=vice
//@version=1

// 参数定义
fastPeriod = I.int(12, '快线周期', 1, 50, 1, '基础参数', '快速EMA周期')
slowPeriod = I.int(26, '慢线周期', 1, 100, 1, '基础参数', '慢速EMA周期')
signalPeriod = I.int(9, 'DEA周期', 1, 50, 1, '基础参数', 'DEA平滑周期')

// 显示控制
showDIF = I.bool(true, '显示DIF线', '显示设置', '显示DIF线')
showDEA = I.bool(true, '显示DEA线', '显示设置', '显示DEA线')
showMACD = I.bool(true, '显示MACD柱', '显示设置', '显示MACD柱状图')
showSignals = I.bool(true, '显示信号', '显示设置', '显示交叉信号')
showZeroLine = I.bool(true, '显示零轴', '显示设置', '显示零轴线')

// 高级设置
colorMode = I.select('gradient', ['single', 'gradient', 'trend'], '柱状图着色', '高级设置', '柱状图颜色模式')
sensitivity = I.float(0.01, '信号灵敏度', 0.001, 0.1, 0.001, '高级设置', '信号触发最小变化')

// 样式定义 - 线条
difStyle = S.line('#FF9900', 1, 'solid', showDIF, 'DIF线样式')
deaStyle = S.line('#0066CC', 1, 'solid', showDEA, 'DEA线样式')
zeroStyle = S.line('#999999', 1, 'solid', showZeroLine, '零轴线样式')

// 样式定义 - MACD柱状图（四种状态）
macdBullUp = S.bar('#00C851', 'stroke', 1, 'solid', showMACD, '多头增强')
macdBullDown = S.bar('#00C851', 'fill', 1, 'solid', showMACD, '多头减弱')
macdBearUp = S.bar('#FF4444', 'stroke', 1, 'solid', showMACD, '空头减弱')  
macdBearDown = S.bar('#FF4444', 'fill', 1, 'solid', showMACD, '空头增强')

// 信号样式
goldenCrossStyle = S.shape('arrowUp', '#00C851', 12, 'value', 'fill', showSignals, '金叉信号')
deathCrossStyle = S.shape('arrowDown', '#FF4444', 12, 'value', 'fill', showSignals, '死叉信号')

// 计算MACD
macdResult = F.macd(dataList, fastPeriod, slowPeriod, signalPeriod)
difData = F.attr(macdResult, 'dif')
deaData = F.attr(macdResult, 'dea')
macdData = F.attr(macdResult, 'macd')

// 绘制零轴线
if (showZeroLine) {
    D.hline(0, zeroStyle)
}

// 动态柱状图绘制
if (showMACD) {
    D.bar(macdData, 0, ({value, prev, index}) => {
        if (value === null || prev === null) return macdBullUp
        
        switch(colorMode) {
            case 'gradient':
                // 渐变模式：基于数值大小
                const intensity = Math.min(1, Math.abs(value) / 0.5)
                if (value >= 0) {
                    const color = value >= prev ? 
                        `rgba(0, 200, 81, ${0.5 + intensity * 0.5})` : 
                        `rgba(0, 200, 81, ${0.3 + intensity * 0.3})`
                    return {color, full: value >= prev ? 'stroke' : 'fill'}
                } else {
                    const color = value >= prev ? 
                        `rgba(255, 68, 68, ${0.3 + intensity * 0.3})` : 
                        `rgba(255, 68, 68, ${0.5 + intensity * 0.5})`
                    return {color, full: value >= prev ? 'stroke' : 'fill'}
                }
                
            case 'trend':
                // 趋势模式：基于DIF和DEA关系
                const dif = difData[index]
                const dea = deaData[index]
                if (dif > dea) {
                    return value >= prev ? macdBullUp : macdBullDown
                } else {
                    return value >= prev ? macdBearUp : macdBearDown
                }
                
            default: // single
                // 单色模式：基于正负和增减
                if (value >= 0) {
                    return value >= prev ? macdBullUp : macdBullDown
                } else {
                    return value >= prev ? macdBearUp : macdBearDown
                }
        }
    })
}

// 绘制DIF和DEA线
if (showDIF) D.line(difData, difStyle)
if (showDEA) D.line(deaData, deaStyle)

// 信号检测和绘制
if (showSignals) {
    const goldenCross = F.throughUp(difData, deaData)
    const deathCross = F.throughDown(difData, deaData)
    
    // 信号过滤：只有变化超过灵敏度才显示
    const filteredGolden = goldenCross.map((signal, index) => {
        if (signal === null) return null
        const change = Math.abs(difData[index] - deaData[index])
        return change >= sensitivity ? signal : null
    })
    
    const filteredDeath = deathCross.map((signal, index) => {
        if (signal === null) return null
        const change = Math.abs(difData[index] - deaData[index])
        return change >= sensitivity ? signal : null
    })
    
    D.shape(filteredGolden, goldenCrossStyle)
    D.shape(filteredDeath, deathCrossStyle)
    
    // 信号统计
    const goldenCount = U.filter(filteredGolden, s => s !== null).length
    const deathCount = U.filter(filteredDeath, s => s !== null).length
    O.print(`金叉信号: ${goldenCount}, 死叉信号: ${deathCount}`)
}

// 副图设置
setPrecision(4)

// 输出设置
if (showDIF) O.tools(`DIF(${fastPeriod},${slowPeriod})`, difData, difStyle)
if (showDEA) O.tools(`DEA(${signalPeriod})`, deaData, deaStyle)
if (showMACD) O.tools('MACD', macdData, {color: '#666666'})

// 当前状态分析
const currentDIF = difData[difData.length - 1]
const currentDEA = deaData[deaData.length - 1]
const currentMACD = macdData[macdData.length - 1]

if (currentDIF !== null && currentDEA !== null && currentMACD !== null) {
    const trend = currentDIF > currentDEA ? '多头' : '空头'
    const momentum = currentMACD > 0 ? '正向' : '负向'
    const strength = Math.abs(currentMACD)
    
    O.print(`=== MACD状态分析 ===`)
    O.print(`当前趋势: ${trend}`)
    O.print(`动量方向: ${momentum}`)
    O.print(`动量强度: ${strength.toFixed(4)}`)
    O.print(`DIF: ${currentDIF.toFixed(4)}`)
    O.print(`DEA: ${currentDEA.toFixed(4)}`)
}
```

## 🔴 高级案例

### 案例5：多时间框架SuperTrend
*难度：⭐⭐⭐ 高级 | 方法：全方法综合应用*

```javascript
//@name=SuperTrend多时间框架
//@title=Multi-Timeframe SuperTrend 多时间框架超级趋势
//@desc=## 多时间框架SuperTrend指标
//基于ATR的趋势跟踪指标，支持多时间框架验证
//#### 特色功能：
//- **动态ATR**: 自适应市场波动
//- **多重确认**: 不同时间框架趋势一致性
//- **智能过滤**: 减少假信号
//- **风险管理**: 自动止损位计算
//#### 使用建议：
//- 绿色: 强势上涨，持有多单
//- 红色: 强势下跌，持有空单
//- 变色点: 趋势转折，调整仓位
//@position=main
//@version=1

// === 基础参数组 ===
atrPeriod = I.int(10, 'ATR周期', 1, 50, 1, '基础参数', 'ATR计算周期')
multiplier = I.float(3.0, 'ATR倍数', 0.1, 10.0, 0.1, '基础参数', 'ATR乘数')
source = I.select('hlc3', SOURCE, '价格源', '基础参数', '计算价格源')

// === 多时间框架设置 ===
enableMTF = I.bool(true, '启用多时间框架', '时间框架', '启用多时间框架确认')
higherTF = I.select('1h', ['15m', '1h', '4h', '1d'], '高级时间框架', '时间框架', '高级时间框架')
mtfWeight = I.float(0.3, 'MTF权重', 0.1, 0.9, 0.1, '时间框架', '高级时间框架权重')

// === 高级过滤器 ===
enableFilters = I.bool(true, '启用过滤器', '过滤设置', '启用智能过滤器')
volumeFilter = I.bool(true, '成交量过滤', '过滤设置', '成交量异常过滤')
volatilityFilter = I.bool(true, '波动率过滤', '过滤设置', '波动率异常过滤')
minVolumeRatio = I.float(0.5, '最小成交量比', 0.1, 2.0, 0.1, '过滤设置', '相对平均成交量最小比例')

// === 风险管理 ===
showStopLoss = I.bool(true, '显示止损', '风险管理', '显示止损位')
stopLossMultiplier = I.float(1.5, '止损倍数', 0.5, 3.0, 0.1, '风险管理', '止损ATR倍数')
showSupport = I.bool(true, '显示支撑阻力', '风险管理', '显示关键位')

// === 显示控制 ===
showTrend = I.bool(true, '显示趋势', '显示设置', '显示主趋势线')
showSignals = I.bool(true, '显示信号', '显示设置', '显示买卖信号')
showInfo = I.bool(true, '显示信息', '显示设置', '显示状态信息')
trendTransparency = I.float(0.8, '趋势透明度', 0.1, 1.0, 0.1, '显示设置', '趋势线透明度')

// === 样式定义 ===
upTrendStyle = S.line(`rgba(0, 200, 81, ${trendTransparency})`, 3, 'solid', showTrend, '上升趋势')
downTrendStyle = S.line(`rgba(255, 68, 68, ${trendTransparency})`, 3, 'solid', showTrend, '下降趋势')
neutralStyle = S.line(`rgba(255, 179, 0, ${trendTransparency})`, 2, 'dashed', showTrend, '中性趋势')

// 止损样式
stopLossUpStyle = S.line('rgba(0, 200, 81, 0.5)', 1, 'dotted', showStopLoss, '多头止损')
stopLossDownStyle = S.line('rgba(255, 68, 68, 0.5)', 1, 'dotted', showStopLoss, '空头止损')

// 信号样式
buySignalStyle = S.shape('arrowUp', '#00C851', 16, 'lowDown', 'fill', showSignals, '买入信号')
sellSignalStyle = S.shape('arrowDown', '#FF4444', 16, 'highUp', 'fill', showSignals, '卖出信号')

// === 核心计算函数 ===
function calculateSuperTrend(data, atrLen, mult, src) {
    const prices = F.attr(data, src)
    const atr = F.atr(data, atrLen)
    
    const hl2 = F.attr(data, 'hl2')
    const upperBand = hl2.map((price, i) => 
        atr[i] !== null ? price + (mult * atr[i]) : null
    )
    const lowerBand = hl2.map((price, i) => 
        atr[i] !== null ? price - (mult * atr[i]) : null
    )
    
    // SuperTrend计算
    let superTrend = new Array(data.length).fill(null)
    let direction = new Array(data.length).fill(1)
    
    for (let i = 1; i < data.length; i++) {
        if (upperBand[i] === null || lowerBand[i] === null) continue
        
        // 更新趋势方向
        if (prices[i] > superTrend[i-1]) {
            direction[i] = 1
        } else if (prices[i] < superTrend[i-1]) {
            direction[i] = -1
        } else {
            direction[i] = direction[i-1]
        }
        
        // 计算SuperTrend值
        if (direction[i] === 1) {
            superTrend[i] = lowerBand[i]
        } else {
            superTrend[i] = upperBand[i]
        }
    }
    
    return {superTrend, direction, upperBand, lowerBand, atr}
}

// === 多时间框架处理 ===
function getMultiTimeframeSignal(current, higher, weight) {
    if (!enableMTF || current === null || higher === null) return current
    
    // 简化的多时间框架逻辑
    const agreement = (current > 0 && higher > 0) || (current < 0 && higher < 0)
    return agreement ? current * (1 + weight) : current * (1 - weight)
}

// === 过滤器函数 ===
function applyFilters(signal, index) {
    if (!enableFilters || signal === null) return signal
    
    const kline = dataList[index]
    if (!kline) return null
    
    // 成交量过滤
    if (volumeFilter) {
        const avgVolume = U.avg(F.attr(dataList.slice(Math.max(0, index - 20), index), 'volume'))
        if (kline.volume < avgVolume * minVolumeRatio) return null
    }
    
    // 波动率过滤
    if (volatilityFilter) {
        const priceChange = Math.abs(kline.close - kline.open) / kline.open
        if (priceChange > 0.15) return null  // 超过15%的剧烈波动
    }
    
    return signal
}

// === 主要计算 ===
const stResult = calculateSuperTrend(dataList, atrPeriod, multiplier, source)
const {superTrend, direction, upperBand, lowerBand, atr} = stResult

// 多时间框架处理（简化版）
let mtfDirection = direction
if (enableMTF) {
    // 这里应该获取高级时间框架数据，简化处理
    mtfDirection = direction.map((dir, i) => getMultiTimeframeSignal(dir, dir, mtfWeight))
}

// 趋势信号生成
const trendUp = superTrend.map((st, i) => direction[i] === 1 ? st : null)
const trendDown = superTrend.map((st, i) => direction[i] === -1 ? st : null)

// 买卖信号检测
let buySignals = []
let sellSignals = []
let prevDirection = null

direction.forEach((dir, i) => {
    if (prevDirection !== null) {
        if (prevDirection === -1 && dir === 1) {
            const filteredSignal = applyFilters({value: superTrend[i]}, i)
            buySignals[i] = filteredSignal
        } else if (prevDirection === 1 && dir === -1) {
            const filteredSignal = applyFilters({value: superTrend[i]}, i)
            sellSignals[i] = filteredSignal
        }
    }
    prevDirection = dir
})

// 止损位计算
const stopLossUp = trendUp.map((trend, i) => 
    trend !== null && atr[i] !== null ? trend - (atr[i] * stopLossMultiplier) : null
)
const stopLossDown = trendDown.map((trend, i) => 
    trend !== null && atr[i] !== null ? trend + (atr[i] * stopLossMultiplier) : null
)

// === 绘图 ===
if (showTrend) {
    D.line(trendUp, upTrendStyle)
    D.line(trendDown, downTrendStyle)
}

if (showStopLoss) {
    D.line(stopLossUp, stopLossUpStyle)
    D.line(stopLossDown, stopLossDownStyle)
}

if (showSignals) {
    D.shape(buySignals, buySignalStyle)
    D.shape(sellSignals, sellSignalStyle)
}

// === 输出和信息 ===
setPrecision('price')
O.tools('SuperTrend', superTrend, {color: '#FF6600'})

if (showStopLoss) {
    O.tools('多头止损', stopLossUp, stopLossUpStyle)
    O.tools('空头止损', stopLossDown, stopLossDownStyle)
}

// 当前状态分析
const currentDirection = direction[direction.length - 1]
const currentST = superTrend[superTrend.length - 1]
const currentPrice = F.attr(dataList, 'close')[dataList.length - 1]
const currentATR = atr[atr.length - 1]

if (showInfo && currentDirection && currentST && currentPrice && currentATR) {
    const trend = currentDirection === 1 ? '上升' : '下降'
    const distance = Math.abs(currentPrice - currentST)
    const atrRatio = distance / currentATR
    
    O.print(`=== SuperTrend状态 ===`)
    O.print(`当前趋势: ${trend}`)
    O.print(`SuperTrend: ${currentST.toFixed(2)}`)
    O.print(`当前价格: ${currentPrice.toFixed(2)}`)
    O.print(`价格距离: ${distance.toFixed(2)} (${atrRatio.toFixed(2)} ATR)`)
    
    if (currentDirection === 1) {
        const stopLevel = currentST - (currentATR * stopLossMultiplier)
        O.print(`建议止损: ${stopLevel.toFixed(2)}`)
    } else {
        const stopLevel = currentST + (currentATR * stopLossMultiplier)
        O.print(`建议止损: ${stopLevel.toFixed(2)}`)
    }
}

// 统计信息
const buyCount = U.filter(buySignals, s => s !== null).length
const sellCount = U.filter(sellSignals, s => s !== null).length
O.print(`买入信号: ${buyCount}, 卖出信号: ${sellCount}`)

// 性能统计
if (enableFilters) {
    O.print('过滤器已启用，信号质量优化中')
}
if (enableMTF) {
    O.print(`多时间框架确认: ${higherTF}`)
}
```

## 🛠️ 实用工具案例

### 案例6：智能支撑阻力识别
*难度：⭐⭐ 实用工具*

```javascript
//@name=智能支撑阻力
//@title=Smart Support Resistance 智能支撑阻力识别
//@desc=## 智能支撑阻力识别工具
//自动识别关键支撑阻力位的实用工具
//#### 识别方法：
//- **价格集中度**: 统计价格分布密度
//- **成交量确认**: 结合成交量验证有效性  
//- **时间强度**: 考虑时间因素加权
//#### 实用功能：
//- 自动标注关键位
//- 强度评级显示
//- 突破信号提醒
//@position=main
//@version=1

// 参数设置
lookback = I.int(100, '回看周期', 20, 500, 10, '分析参数', '支撑阻力分析周期')
minTouches = I.int(3, '最少触碰次数', 2, 10, 1, '分析参数', '形成支撑阻力的最少触碰次数')
priceThreshold = I.float(0.5, '价格容差%', 0.1, 2.0, 0.1, '分析参数', '价格匹配容差百分比')
volumeWeight = I.float(0.3, '成交量权重', 0, 1, 0.1, '分析参数', '成交量确认权重')

// 显示控制
showSR = I.bool(true, '显示支撑阻力', '显示设置', '显示支撑阻力线')
showLabels = I.bool(true, '显示标签', '显示设置', '显示价格和强度标签')
showBreakout = I.bool(true, '显示突破', '显示设置', '显示突破信号')
maxLines = I.int(5, '最大显示线数', 1, 20, 1, '显示设置', '最多显示的支撑阻力线数量')

// 样式定义
supportStyle = S.line('#4CAF50', 2, 'solid', showSR, '支撑线样式')
resistanceStyle = S.line('#F44336', 2, 'solid', showSR, '阻力线样式')
weakSRStyle = S.line('#FFC107', 1, 'dashed', showSR, '弱支撑阻力')

// 标签和信号样式
srLabelStyle = S.label('#FFFFFF', 12, 'left', 'value', title='SR标签')
labelBgStyle = S.labelbg('rgba(0,0,0,0.7)', 'fill', title='标签背景')
breakoutUpStyle = S.shape('triangleUp', '#00C851', 14, 'value', 'fill', showBreakout, '向上突破')
breakoutDownStyle = S.shape('triangleDown', '#FF4444', 14, 'value', 'fill', showBreakout, '向下突破')

// 支撑阻力识别算法
function identifySupportResistance(data, lookbackPeriod, threshold, minTouch) {
    const levels = []
    const highs = F.attr(data, 'high')
    const lows = F.attr(data, 'low')
    const closes = F.attr(data, 'close')
    const volumes = F.attr(data, 'volume')
    
    // 获取分析区间
    const startIndex = Math.max(0, data.length - lookbackPeriod)
    const analysisData = data.slice(startIndex)
    
    // 寻找潜在的关键价位
    const pricePoints = []
    
    // 收集高低点
    analysisData.forEach((kline, i) => {
        const globalIndex = startIndex + i
        
        // 局部高点检测
        if (i >= 2 && i < analysisData.length - 2) {
            const isLocalHigh = kline.high > analysisData[i-1].high && 
                               kline.high > analysisData[i-2].high &&
                               kline.high > analysisData[i+1].high && 
                               kline.high > analysisData[i+2].high
            
            if (isLocalHigh) {
                pricePoints.push({
                    price: kline.high,
                    index: globalIndex,
                    type: 'resistance',
                    volume: kline.volume,
                    timestamp: kline.timestamp
                })
            }
            
            // 局部低点检测
            const isLocalLow = kline.low < analysisData[i-1].low && 
                              kline.low < analysisData[i-2].low &&
                              kline.low < analysisData[i+1].low && 
                              kline.low < analysisData[i+2].low
            
            if (isLocalLow) {
                pricePoints.push({
                    price: kline.low,
                    index: globalIndex,
                    type: 'support',
                    volume: kline.volume,
                    timestamp: kline.timestamp
                })
            }
        }
    })
    
    // 聚类分析相近价位
    const clusters = []
    pricePoints.forEach(point => {
        let addedToCluster = false
        
        for (let cluster of clusters) {
            const priceDiff = Math.abs(point.price - cluster.avgPrice) / cluster.avgPrice
            if (priceDiff <= threshold / 100) {
                cluster.points.push(point)
                cluster.totalVolume += point.volume
                cluster.avgPrice = cluster.points.reduce((sum, p) => sum + p.price, 0) / cluster.points.length
                cluster.strength = cluster.points.length + (cluster.totalVolume / 1000000) * volumeWeight
                addedToCluster = true
                break
            }
        }
        
        if (!addedToCluster) {
            clusters.push({
                avgPrice: point.price,
                points: [point],
                type: point.type,
                totalVolume: point.volume,
                strength: 1 + (point.volume / 1000000) * volumeWeight
            })
        }
    })
    
    // 过滤和排序
    const validClusters = clusters
        .filter(cluster => cluster.points.length >= minTouch)
        .sort((a, b) => b.strength - a.strength)
        .slice(0, maxLines)
    
    return validClusters
}

// 执行支撑阻力识别
const srLevels = identifySupportResistance(dataList, lookback, priceThreshold, minTouches)

// 绘制支撑阻力线
srLevels.forEach((level, index) => {
    const levelArray = new Array(dataList.length).fill(level.avgPrice)
    
    // 选择样式
    let style
    if (level.strength >= 5) {
        style = level.type === 'support' ? supportStyle : resistanceStyle
    } else {
        style = weakSRStyle
    }
    
    // 绘制水平线
    if (showSR) {
        D.hline(level.avgPrice, style)
    }
    
    // 绘制标签
    if (showLabels) {
        const labelText = `${level.type === 'support' ? 'S' : 'R'}:${level.avgPrice.toFixed(2)}(${level.strength.toFixed(1)})`
        const labelArray = new Array(dataList.length).fill(null)
        labelArray[dataList.length - 1] = labelText
        
        D.label(labelArray, srLabelStyle, labelBgStyle)
    }
})

// 突破检测
if (showBreakout && srLevels.length > 0) {
    const currentPrice = dataList[dataList.length - 1]?.close
    const prevPrice = dataList[dataList.length - 2]?.close
    
    if (currentPrice && prevPrice) {
        srLevels.forEach(level => {
            const priceDiff = Math.abs(currentPrice - level.avgPrice) / level.avgPrice
            
            if (priceDiff <= 0.002) { // 0.2% 容差内认为触及
                let breakoutSignal = null
                
                if (level.type === 'support' && prevPrice > level.avgPrice && currentPrice <= level.avgPrice) {
                    breakoutSignal = new Array(dataList.length).fill(null)
                    breakoutSignal[dataList.length - 1] = {value: currentPrice}
                    D.shape(breakoutSignal, breakoutDownStyle)
                    O.notify(`支撑位突破: ${level.avgPrice.toFixed(2)}`, 'warning')
                }
                
                if (level.type === 'resistance' && prevPrice < level.avgPrice && currentPrice >= level.avgPrice) {
                    breakoutSignal = new Array(dataList.length).fill(null)
                    breakoutSignal[dataList.length - 1] = {value: currentPrice}
                    D.shape(breakoutSignal, breakoutUpStyle)
                    O.notify(`阻力位突破: ${level.avgPrice.toFixed(2)}`, 'success')
                }
            }
        })
    }
}

// 输出信息
setPrecision('price')

// 输出支撑阻力位信息
if (srLevels.length > 0) {
    O.print('=== 支撑阻力位分析 ===')
    srLevels.forEach((level, index) => {
        const typeText = level.type === 'support' ? '支撑' : '阻力'
        O.print(`${typeText}位 ${index + 1}: ${level.avgPrice.toFixed(2)} (强度: ${level.strength.toFixed(1)}, 触碰: ${level.points.length}次)`)
        
        // 输出到工具面板
        const levelArray = new Array(dataList.length).fill(level.avgPrice)
        const style = level.type === 'support' ? supportStyle : resistanceStyle
        O.tools(`${typeText}${index + 1}`, levelArray, style)
    })
    
    // 当前价格分析
    const currentPrice = dataList[dataList.length - 1]?.close
    if (currentPrice) {
        O.print(`当前价格: ${currentPrice.toFixed(2)}`)
        
        // 找到最近的支撑和阻力
        let nearestSupport = null
        let nearestResistance = null
        
        srLevels.forEach(level => {
            if (level.type === 'support' && level.avgPrice < currentPrice) {
                if (!nearestSupport || level.avgPrice > nearestSupport.avgPrice) {
                    nearestSupport = level
                }
            }
            if (level.type === 'resistance' && level.avgPrice > currentPrice) {
                if (!nearestResistance || level.avgPrice < nearestResistance.avgPrice) {
                    nearestResistance = level
                }
            }
        })
        
        if (nearestSupport) {
            const distance = ((currentPrice - nearestSupport.avgPrice) / nearestSupport.avgPrice * 100).toFixed(2)
            O.print(`最近支撑: ${nearestSupport.avgPrice.toFixed(2)} (距离: +${distance}%)`)
        }
        
        if (nearestResistance) {
            const distance = ((nearestResistance.avgPrice - currentPrice) / currentPrice * 100).toFixed(2)
            O.print(`最近阻力: ${nearestResistance.avgPrice.toFixed(2)} (距离: +${distance}%)`)
        }
    }
} else {
    O.print('在指定参数下未发现明显的支撑阻力位')
}
```

### 案例7：交易信号汇总面板
*难度：⭐⭐ 实用工具*

```javascript
//@name=信号汇总面板
//@title=Signal Dashboard 交易信号汇总面板
//@desc=## 交易信号汇总面板
//集成多个技术指标的综合信号分析工具
//#### 集成指标：
//- **趋势**: MA, EMA, SuperTrend
//- **动量**: RSI, MACD, KDJ  
//- **波动**: Bollinger, ATR
//- **成交量**: OBV, Volume Profile
//#### 信号评分：
//- 强烈买入: 8-10分
//- 买入: 6-7分
//- 中性: 4-5分
//- 卖出: 2-3分
//- 强烈卖出: 0-1分
//@position=vice
//@version=1

// 指标启用开关
enableMA = I.bool(true, '移动平均', '指标选择', '启用移动平均分析')
enableRSI = I.bool(true, 'RSI', '指标选择', '启用RSI分析')
enableMACD = I.bool(true, 'MACD', '指标选择', '启用MACD分析')
enableBoll = I.bool(true, '布林带', '指标选择', '启用布林带分析')
enableVolume = I.bool(true, '成交量', '指标选择', '启用成交量分析')

// 参数设置
maPeriod1 = I.int(5, '短期MA', 1, 50, 1, '参数设置', '短期移动平均周期')
maPeriod2 = I.int(20, '长期MA', 1, 100, 1, '参数设置', '长期移动平均周期')
rsiPeriod = I.int(14, 'RSI周期', 1, 50, 1, '参数设置', 'RSI计算周期')

// 显示设置
showScores = I.bool(true, '显示评分', '显示设置', '显示各指标评分')
showSignals = I.bool(true, '显示信号', '显示设置', '显示买卖信号')
showPanel = I.bool(true, '显示面板', '显示设置', '显示信息面板')

// 信号强度阈值
strongSignalThreshold = I.int(8, '强信号阈值', 6, 10, 1, '信号设置', '强信号评分阈值')
weakSignalThreshold = I.int(3, '弱信号阈值', 0, 5, 1, '信号设置', '弱信号评分阈值')

// 样式定义
panelTextStyle = S.slabel('#FFFFFF', 12, 'left', 'normal')
panelBgStyle = S.labelbg('rgba(0, 0, 0, 0.8)', 'fill')

strongBuyStyle = S.shape('arrowUp', '#00C851', 16, 'lowDown', 'fill', title='强烈买入')
buyStyle = S.shape('arrowUp', '#4CAF50', 14, 'lowDown', 'stroke', title='买入')
sellStyle = S.shape('arrowDown', '#FF9800', 14, 'highUp', 'stroke', title='卖出')
strongSellStyle = S.shape('arrowDown', '#FF4444', 16, 'highUp', 'fill', title='强烈卖出')

// 信号评估函数
function evaluateSignals() {
    const signals = {
        ma: { score: 5, signal: 'neutral', description: '中性' },
        rsi: { score: 5, signal: 'neutral', description: '中性' },
        macd: { score: 5, signal: 'neutral', description: '中性' },
        boll: { score: 5, signal: 'neutral', description: '中性' },
        volume: { score: 5, signal: 'neutral', description: '中性' }
    }
    
    // MA信号评估
    if (enableMA) {
        const ma5 = F.ma(dataList, maPeriod1, 'close')
        const ma20 = F.ma(dataList, maPeriod2, 'close')
        const currentMA5 = ma5[ma5.length - 1]
        const currentMA20 = ma20[ma20.length - 1]
        const currentPrice = dataList[dataList.length - 1]?.close
        
        if (currentMA5 && currentMA20 && currentPrice) {
            let score = 5
            
            // 均线排列
            if (currentMA5 > currentMA20) score += 2
            else score -= 2
            
            // 价格与均线关系
            if (currentPrice > currentMA5 && currentPrice > currentMA20) score += 2
            else if (currentPrice < currentMA5 && currentPrice < currentMA20) score -= 2
            
            // 均线斜率
            if (ma5.length >= 3) {
                const ma5Slope = (currentMA5 - ma5[ma5.length - 3]) / ma5[ma5.length - 3]
                if (ma5Slope > 0.001) score += 1
                else if (ma5Slope < -0.001) score -= 1
            }
            
            signals.ma.score = Math.max(0, Math.min(10, score))
            signals.ma.signal = score >= 7 ? 'buy' : score <= 3 ? 'sell' : 'neutral'
            signals.ma.description = `MA5:${currentMA5.toFixed(2)} MA20:${currentMA20.toFixed(2)}`
        }
    }
    
    // RSI信号评估
    if (enableRSI) {
        const rsi = F.rsi(dataList, rsiPeriod)
        const currentRSI = rsi[rsi.length - 1]
        
        if (currentRSI !== null) {
            let score = 5
            
            if (currentRSI > 70) score = 2  // 超买
            else if (currentRSI > 60) score = 3
            else if (currentRSI > 50) score = 6
            else if (currentRSI > 40) score = 7
            else if (currentRSI > 30) score = 8
            else score = 9  // 超卖
            
            signals.rsi.score = score
            signals.rsi.signal = score >= 7 ? 'buy' : score <= 3 ? 'sell' : 'neutral'
            signals.rsi.description = `RSI:${currentRSI.toFixed(1)}`
        }
    }
    
    // MACD信号评估
    if (enableMACD) {
        const macdResult = F.macd(dataList, 12, 26, 9)
        const dif = F.attr(macdResult, 'dif')
        const dea = F.attr(macdResult, 'dea')
        const macd = F.attr(macdResult, 'macd')
        
        const currentDIF = dif[dif.length - 1]
        const currentDEA = dea[dea.length - 1]
        const currentMACD = macd[macd.length - 1]
        
        if (currentDIF !== null && currentDEA !== null && currentMACD !== null) {
            let score = 5
            
            // DIF与DEA关系
            if (currentDIF > currentDEA) score += 2
            else score -= 2
            
            // MACD值
            if (currentMACD > 0) score += 1
            else score -= 1
            
            // 趋势强度
            if (Math.abs(currentMACD) > 0.1) {
                score += currentMACD > 0 ? 1 : -1
            }
            
            signals.macd.score = Math.max(0, Math.min(10, score))
            signals.macd.signal = score >= 7 ? 'buy' : score <= 3 ? 'sell' : 'neutral'
            signals.macd.description = `MACD:${currentMACD.toFixed(3)}`
        }
    }
    
    // 布林带信号评估
    if (enableBoll) {
        const bollResult = F.boll(dataList, 20, 2)
        const mid = F.attr(bollResult, 'mid')
        const ub = F.attr(bollResult, 'ub')
        const lb = F.attr(bollResult, 'lb')
        
        const currentPrice = dataList[dataList.length - 1]?.close
        const currentMid = mid[mid.length - 1]
        const currentUB = ub[ub.length - 1]
        const currentLB = lb[lb.length - 1]
        
        if (currentPrice && currentMid && currentUB && currentLB) {
            let score = 5
            
            // 价格在布林带中的位置
            const position = (currentPrice - currentLB) / (currentUB - currentLB)
            
            if (position > 0.8) score = 2      // 接近上轨，超买
            else if (position > 0.6) score = 4
            else if (position > 0.4) score = 6
            else if (position > 0.2) score = 8
            else score = 9                     // 接近下轨，超卖
            
            signals.boll.score = score
            signals.boll.signal = score >= 7 ? 'buy' : score <= 3 ? 'sell' : 'neutral'
            signals.boll.description = `位置:${(position * 100).toFixed(0)}%`
        }
    }
    
    // 成交量信号评估
    if (enableVolume) {
        const volumes = F.attr(dataList, 'volume')
        const avgVolume = U.avg(U.slice(volumes, -20))  // 20周期平均成交量
        const currentVolume = volumes[volumes.length - 1]
        const priceChange = ((dataList[dataList.length - 1]?.close - dataList[dataList.length - 2]?.close) / dataList[dataList.length - 2]?.close) || 0
        
        if (currentVolume && avgVolume) {
            let score = 5
            const volumeRatio = currentVolume / avgVolume
            
            // 成交量异常 + 价格变化方向
            if (volumeRatio > 1.5 && priceChange > 0) score = 8     // 放量上涨
            else if (volumeRatio > 1.5 && priceChange < 0) score = 2  // 放量下跌
            else if (volumeRatio < 0.5) score = 4  // 缩量
            
            signals.volume.score = score
            signals.volume.signal = score >= 7 ? 'buy' : score <= 3 ? 'sell' : 'neutral'
            signals.volume.description = `量比:${volumeRatio.toFixed(1)}`
        }
    }
    
    return signals
}

// 执行信号评估
const signalResults = evaluateSignals()

// 计算综合评分
let totalScore = 0
let activeSignals = 0

Object.values(signalResults).forEach(signal => {
    if (signal.score !== 5 || signal.signal !== 'neutral') {  // 排除默认中性信号
        totalScore += signal.score
        activeSignals++
    }
})

const overallScore = activeSignals > 0 ? totalScore / activeSignals : 5
let overallSignal = 'neutral'
let signalStrength = '中性'

if (overallScore >= strongSignalThreshold) {
    overallSignal = 'strong_buy'
    signalStrength = '强烈买入'
} else if (overallScore >= 6) {
    overallSignal = 'buy'
    signalStrength = '买入'
} else if (overallScore <= weakSignalThreshold) {
    overallSignal = 'strong_sell'
    signalStrength = '强烈卖出'
} else if (overallScore <= 4) {
    overallSignal = 'sell'
    signalStrength = '卖出'
}

// 绘制综合信号
if (showSignals) {
    const signalArray = new Array(dataList.length).fill(null)
    signalArray[dataList.length - 1] = {value: overallScore}
    
    switch(overallSignal) {
        case 'strong_buy':
            D.shape(signalArray, strongBuyStyle)
            break
        case 'buy':
            D.shape(signalArray, buyStyle)
            break
        case 'sell':
            D.shape(signalArray, sellStyle)
            break
        case 'strong_sell':
            D.shape(signalArray, strongSellStyle)
            break
    }
}

// 绘制信息面板
if (showPanel) {
    let yPos = 20
    const lineHeight = 18
    
    // 主标题
    D.slabel(20, yPos, `交易信号汇总 - ${signalStrength} (${overallScore.toFixed(1)}/10)`, 
             panelTextStyle, panelBgStyle)
    yPos += lineHeight + 5
    
    // 各指标详情
    if (showScores) {
        Object.entries(signalResults).forEach(([key, signal]) => {
            const indicatorName = {
                ma: '移动平均',
                rsi: 'RSI指标',
                macd: 'MACD',
                boll: '布林带',
                volume: '成交量'
            }[key]
            
            const scoreText = `${indicatorName}: ${signal.score}/10 ${signal.description}`
            const color = signal.score >= 7 ? '#4CAF50' : signal.score <= 3 ? '#FF4444' : '#FFB300'
            
            const coloredStyle = {
                color: color,
                size: 11,
                align: 'left'
            }
            
            D.slabel(20, yPos, scoreText, coloredStyle, panelBgStyle)
            yPos += lineHeight
        })
    }
    
    // 时间信息
    const currentTime = U.formatTime(dataList[dataList.length - 1]?.timestamp || Date.now(), 'MM-DD HH:mm')
    D.slabel(20, yPos + 10, `更新时间: ${currentTime}`, panelTextStyle, panelBgStyle)
}

// 副图设置
setMax(10)
setMin(0)
setPrecision(1)

// 绘制评分图表
const scoreLineData = new Array(dataList.length).fill(overallScore)
const scoreStyle = S.line('#FF6600', 2, 'solid', title='综合评分')
D.line(scoreLineData, scoreStyle)

// 绘制阈值线
D.hline(strongSignalThreshold, S.line('#4CAF50', 1, 'dashed', title='强买入阈值'))
D.hline(5, S.line('#999999', 1, 'dotted', title='中性线'))
D.hline(weakSignalThreshold, S.line('#FF4444', 1, 'dashed', title='强卖出阈值'))

// 输出到工具面板
O.tools('综合评分', scoreLineData, scoreStyle)

// 详细输出
O.print(`=== 交易信号分析报告 ===`)
O.print(`综合评分: ${overallScore.toFixed(1)}/10`)
O.print(`信号强度: ${signalStrength}`)
O.print(`活跃指标: ${activeSignals}个`)

Object.entries(signalResults).forEach(([key, signal]) => {
    const indicatorName = {
        ma: 'MA',
        rsi: 'RSI', 
        macd: 'MACD',
        boll: 'BOLL',
        volume: 'VOL'
    }[key]
    
    O.print(`${indicatorName}: ${signal.score}/10 - ${signal.description}`)
})

// 交易建议
if (overallScore >= 8) {
    O.notify('强烈买入信号！多个指标一致看涨', 'success')
} else if (overallScore <= 2) {
    O.notify('强烈卖出信号！多个指标一致看跌', 'error')
} else if (overallScore >= 6.5) {
    O.notify('买入信号，建议关注入场机会', 'success')
} else if (overallScore <= 3.5) {
    O.notify('卖出信号，建议规避风险', 'warning')
}
```

## 🎓 案例学习指南

### 初学者建议学习顺序
1. **案例1-2**: 掌握基础方法使用
2. **案例3**: 学习多方法组合
3. **案例4**: 理解复杂指标结构
4. **案例5**: 掌握高级编程技巧
5. **案例6-7**: 开发实用工具

### 进阶技巧总结
- **数据验证**: 使用U.isValid()等工具确保数据安全
- **性能优化**: 避免重复计算，复用计算结果
- **错误处理**: 完善的null值处理和异常捕获
- **用户体验**: 丰富的参数设置和信息输出
- **代码组织**: 模块化设计，逻辑清晰

### 自定义开发建议
1. **明确需求**: 确定指标功能和适用场景
2. **设计参数**: 合理的参数分组和默认值
3. **编写逻辑**: 从简单到复杂，逐步实现
4. **测试验证**: 多种市场情况下测试
5. **优化完善**: 性能优化和用户体验改进

## 🔗 相关内容

- **方法详解**: [各方法详解文档](00-主索引.md#方法分类) - 深入学习各种方法
- **编程规范**: [重要规则汇总](01-重要规则汇总.md) - 避免常见错误
- **调试技巧**: [错误处理指南](10-错误处理和调试指南.md) - 问题解决方法
- **最佳实践**: [高级主题](11-高级主题和最佳实践.md) - 进阶编程技巧

---
**提示**: 这些案例展示了GainLab Script从入门到精通的完整路径，建议结合实际需求选择合适的案例进行学习和改进，逐步提升编程水平。