# é«˜çº§ä¸»é¢˜å’Œæœ€ä½³å®è·µ

## ğŸ“‹ æŒ‡å—æ¦‚è¿°

æœ¬æŒ‡å—æ·±å…¥æ¢è®¨GainLab Scriptçš„**é«˜çº§å¼€å‘æŠ€å·§å’Œæœ€ä½³å®è·µ**ï¼Œæ¶µç›–æ¶æ„è®¾è®¡ã€æ€§èƒ½ä¼˜åŒ–ã€ä»£ç è´¨é‡ã€å·¥ç¨‹åŒ–å®è·µç­‰é«˜çº§ä¸»é¢˜ï¼Œå¸®åŠ©å¼€å‘è€…ä»åˆçº§å‘ä¸“å®¶çº§è¿›é˜¶ï¼Œå¼€å‘å‡ºé«˜è´¨é‡ã€é«˜æ€§èƒ½ã€æ˜“ç»´æŠ¤çš„ä¸“ä¸šæŒ‡æ ‡ã€‚

### ğŸ¯ é€‚ç”¨å¯¹è±¡
- ğŸš€ **è¿›é˜¶å¼€å‘è€…** - å·²æŒæ¡åŸºç¡€æ–¹æ³•ï¼Œéœ€è¦æå‡ä»£ç è´¨é‡
- ğŸ’¼ **ä¸“ä¸šå¼€å‘è€…** - å¼€å‘å•†ä¸šçº§æŒ‡æ ‡å’Œå¤æ‚ç³»ç»Ÿ
- ğŸ‘¥ **å›¢é˜Ÿåä½œè€…** - å‚ä¸å¤šäººåä½œé¡¹ç›®çš„å¼€å‘è€…
- ğŸ† **æŠ€æœ¯ä¸“å®¶** - è¿½æ±‚ä»£ç è‰ºæœ¯å’Œæè‡´æ€§èƒ½çš„å¼€å‘è€…

### ğŸ“š å†…å®¹ç»“æ„
- ğŸ—ï¸ **æ¶æ„è®¾è®¡** - æ¨¡å—åŒ–è®¾è®¡å’Œä»£ç ç»„ç»‡
- âš¡ **æ€§èƒ½ä¼˜åŒ–** - è®¡ç®—æ€§èƒ½å’Œå†…å­˜ç®¡ç†
- ğŸ¨ **è®¾è®¡æ¨¡å¼** - é«˜çº§ç¼–ç¨‹æ¨¡å¼å’ŒæŠ€å·§
- ğŸ“ **ç¼–ç è§„èŒƒ** - ä»£ç è´¨é‡å’Œæœ€ä½³å®è·µæ ‡å‡†
- ğŸ› ï¸ **å·¥ç¨‹åŒ–** - å¼€å‘æµç¨‹å’Œé¡¹ç›®ç®¡ç†

## ğŸ—ï¸ æ¶æ„è®¾è®¡æ¨¡å¼

### åˆ†å±‚æ¶æ„è®¾è®¡

#### æ ‡å‡†ä¸‰å±‚æ¶æ„
```javascript
//@name=æ¶æ„ç¤ºä¾‹-ä¸‰å±‚è®¾è®¡
//@position=main
//@version=1

// =====================================
// ç¬¬ä¸€å±‚ï¼šé…ç½®å’Œå‚æ•°å±‚ (Configuration Layer)
// =====================================
const CONFIG = {
    // ä¸šåŠ¡å‚æ•°
    PERIODS: {
        FAST: I.int(5, 'å¿«çº¿å‘¨æœŸ', 1, 50, 1, 'æ ¸å¿ƒå‚æ•°'),
        SLOW: I.int(20, 'æ…¢çº¿å‘¨æœŸ', 5, 200, 1, 'æ ¸å¿ƒå‚æ•°'),
        SIGNAL: I.int(9, 'ä¿¡å·å‘¨æœŸ', 1, 50, 1, 'æ ¸å¿ƒå‚æ•°')
    },
    
    // æ˜¾ç¤ºæ§åˆ¶
    DISPLAY: {
        SHOW_MA: I.bool(true, 'æ˜¾ç¤ºå‡çº¿', 'æ˜¾ç¤ºæ§åˆ¶'),
        SHOW_SIGNALS: I.bool(true, 'æ˜¾ç¤ºä¿¡å·', 'æ˜¾ç¤ºæ§åˆ¶'),
        SHOW_FILL: I.bool(false, 'æ˜¾ç¤ºå¡«å……', 'æ˜¾ç¤ºæ§åˆ¶')
    },
    
    // æ ·å¼é…ç½®
    STYLES: {
        FAST_LINE: S.line('#FF0000', 2, 'solid', title='å¿«çº¿æ ·å¼'),
        SLOW_LINE: S.line('#0000FF', 2, 'solid', title='æ…¢çº¿æ ·å¼'),
        BUY_SIGNAL: S.shape('arrowUp', '#00C851', 12, 'lowDown', 'fill', title='ä¹°å…¥ä¿¡å·'),
        SELL_SIGNAL: S.shape('arrowDown', '#FF4444', 12, 'highUp', 'fill', title='å–å‡ºä¿¡å·')
    },
    
    // ç®—æ³•å‚æ•°
    ALGO: {
        MIN_SIGNAL_DISTANCE: I.float(0.5, 'æœ€å°ä¿¡å·è·ç¦»%', 0.1, 5.0, 0.1, 'é«˜çº§è®¾ç½®'),
        VOLUME_THRESHOLD: I.float(1.2, 'æˆäº¤é‡é˜ˆå€¼', 0.5, 3.0, 0.1, 'é«˜çº§è®¾ç½®')
    }
}

// =====================================
// ç¬¬äºŒå±‚ï¼šä¸šåŠ¡é€»è¾‘å±‚ (Business Logic Layer)  
// =====================================
const TradingLogic = {
    // æ•°æ®éªŒè¯æ¨¡å—
    DataValidator: {
        validateInput: function(data, minLength = 50) {
            if (!data || !Array.isArray(data)) {
                throw new Error('æ•°æ®æ ¼å¼é”™è¯¯ï¼šéœ€è¦æ•°ç»„')
            }
            
            if (data.length < minLength) {
                throw new Error(`æ•°æ®ä¸è¶³ï¼šéœ€è¦è‡³å°‘${minLength}æ¡ï¼Œå®é™…${data.length}æ¡`)
            }
            
            // éªŒè¯æ•°æ®å®Œæ•´æ€§
            const invalidCount = data.filter(item => 
                !item || !U.isValidNumber(item.close)
            ).length
            
            if (invalidCount / data.length > 0.1) {
                O.print(`è­¦å‘Šï¼š${invalidCount}æ¡æ•°æ®æ— æ•ˆ (${(invalidCount/data.length*100).toFixed(1)}%)`, 'warn')
            }
            
            return true
        },
        
        validateParameters: function(config) {
            if (config.PERIODS.FAST >= config.PERIODS.SLOW) {
                throw new Error('å¿«çº¿å‘¨æœŸå¿…é¡»å°äºæ…¢çº¿å‘¨æœŸ')
            }
            
            return true
        }
    },
    
    // æ ¸å¿ƒè®¡ç®—æ¨¡å—
    Calculator: {
        computeMovingAverages: function(data, fastPeriod, slowPeriod) {
            return {
                fast: F.ma(data, fastPeriod, 'close'),
                slow: F.ma(data, slowPeriod, 'close')
            }
        },
        
        computeSignals: function(fastMA, slowMA, config) {
            const rawBuy = F.throughUp(fastMA, slowMA)
            const rawSell = F.throughDown(fastMA, slowMA)
            
            // åº”ç”¨è¿‡æ»¤å™¨
            return {
                buy: this.filterSignals(rawBuy, fastMA, slowMA, config),
                sell: this.filterSignals(rawSell, fastMA, slowMA, config)
            }
        },
        
        filterSignals: function(signals, fastMA, slowMA, config) {
            return signals.map((signal, index) => {
                if (signal === null) return null
                
                // è·ç¦»è¿‡æ»¤
                const distance = Math.abs(fastMA[index] - slowMA[index]) / slowMA[index] * 100
                if (distance < config.ALGO.MIN_SIGNAL_DISTANCE) {
                    return null
                }
                
                // æˆäº¤é‡è¿‡æ»¤
                const kline = dataList[index]
                if (kline) {
                    const recentVolumes = U.slice(F.attr(dataList, 'volume'), Math.max(0, index - 20), index + 1)
                    const avgVolume = U.avg(recentVolumes.filter(v => U.isValidNumber(v)))
                    
                    if (kline.volume < avgVolume * config.ALGO.VOLUME_THRESHOLD) {
                        return null
                    }
                }
                
                return signal
            })
        }
    },
    
    // åˆ†ææ¨¡å—
    Analyzer: {
        generateReport: function(fastMA, slowMA, signals) {
            const trend = this.analyzeTrend(fastMA, slowMA)
            const signalStats = this.analyzeSignals(signals)
            
            return {
                trend: trend,
                signals: signalStats,
                recommendation: this.generateRecommendation(trend, signalStats)
            }
        },
        
        analyzeTrend: function(fastMA, slowMA) {
            const currentFast = fastMA[fastMA.length - 1]
            const currentSlow = slowMA[slowMA.length - 1]
            
            if (!currentFast || !currentSlow) return 'unknown'
            
            const direction = currentFast > currentSlow ? 'bullish' : 'bearish'
            const strength = Math.abs(currentFast - currentSlow) / currentSlow * 100
            
            return {
                direction: direction,
                strength: strength,
                description: strength > 2 ? 'strong' : strength > 1 ? 'medium' : 'weak'
            }
        },
        
        analyzeSignals: function(signals) {
            const buyCount = signals.buy.filter(s => s !== null).length
            const sellCount = signals.sell.filter(s => s !== null).length
            
            return {
                buySignals: buyCount,
                sellSignals: sellCount,
                total: buyCount + sellCount,
                ratio: buyCount / (buyCount + sellCount) || 0
            }
        },
        
        generateRecommendation: function(trend, signals) {
            if (trend.direction === 'bullish' && trend.strength > 1.5 && signals.ratio > 0.6) {
                return { action: 'strong_buy', confidence: 0.8 }
            } else if (trend.direction === 'bearish' && trend.strength > 1.5 && signals.ratio < 0.4) {
                return { action: 'strong_sell', confidence: 0.8 }
            } else {
                return { action: 'hold', confidence: 0.5 }
            }
        }
    }
}

// =====================================
// ç¬¬ä¸‰å±‚ï¼šè¡¨ç°å±‚ (Presentation Layer)
// =====================================
const Renderer = {
    // å›¾å½¢æ¸²æŸ“ç®¡ç†å™¨
    GraphicsManager: {
        renderMovingAverages: function(data, styles, display) {
            if (display.SHOW_MA) {
                D.line(data.fast, styles.FAST_LINE)
                D.line(data.slow, styles.SLOW_LINE)
                
                // æ¡ä»¶å¡«å……
                if (display.SHOW_FILL) {
                    const fillStyle = S.area('rgba(255, 0, 0, 0.1)', true)
                    D.area(data.fast, data.slow, fillStyle)
                }
            }
        },
        
        renderSignals: function(signals, styles, display) {
            if (display.SHOW_SIGNALS) {
                D.shape(signals.buy, styles.BUY_SIGNAL)
                D.shape(signals.sell, styles.SELL_SIGNAL)
            }
        },
        
        renderInfoPanel: function(analysis) {
            // åŠ¨æ€ä¿¡æ¯é¢æ¿
            const panelData = [
                `è¶‹åŠ¿: ${analysis.trend.direction} (${analysis.trend.description})`,
                `ä¿¡å·ç»Ÿè®¡: ä¹°å…¥${analysis.signals.buySignals} å–å‡º${analysis.signals.sellSignals}`,
                `å»ºè®®: ${analysis.recommendation.action} (ç½®ä¿¡åº¦${(analysis.recommendation.confidence*100).toFixed(0)}%)`
            ]
            
            panelData.forEach((text, index) => {
                D.slabel(20, 20 + index * 20, text, 
                    S.slabel('#FFFFFF', 12, 'left'), 
                    S.labelbg('rgba(0,0,0,0.7)', 'fill'))
            })
        }
    },
    
    // è¾“å‡ºç®¡ç†å™¨
    OutputManager: {
        setupOutput: function() {
            setPrecision('price')
        },
        
        outputToTools: function(data, styles, config) {
            O.tools(`MA${config.PERIODS.FAST}`, data.fast, styles.FAST_LINE)
            O.tools(`MA${config.PERIODS.SLOW}`, data.slow, styles.SLOW_LINE)
        },
        
        outputAnalysis: function(analysis) {
            O.print('=== æŠ€æœ¯åˆ†ææŠ¥å‘Š ===')
            O.print(`è¶‹åŠ¿æ–¹å‘: ${analysis.trend.direction}`)
            O.print(`è¶‹åŠ¿å¼ºåº¦: ${analysis.trend.strength.toFixed(2)}%`)
            O.print(`ä¹°å…¥ä¿¡å·: ${analysis.signals.buySignals}ä¸ª`)
            O.print(`å–å‡ºä¿¡å·: ${analysis.signals.sellSignals}ä¸ª`)
            O.print(`äº¤æ˜“å»ºè®®: ${analysis.recommendation.action}`)
        }
    }
}

// =====================================
// ä¸»ç¨‹åºæ‰§è¡Œ (Main Execution)
// =====================================
try {
    // æ•°æ®éªŒè¯
    TradingLogic.DataValidator.validateInput(dataList, CONFIG.PERIODS.SLOW)
    TradingLogic.DataValidator.validateParameters(CONFIG)
    
    // æ ¸å¿ƒè®¡ç®—
    const maData = TradingLogic.Calculator.computeMovingAverages(
        dataList, CONFIG.PERIODS.FAST, CONFIG.PERIODS.SLOW
    )
    
    const signals = TradingLogic.Calculator.computeSignals(
        maData.fast, maData.slow, CONFIG
    )
    
    // æ•°æ®åˆ†æ
    const analysis = TradingLogic.Analyzer.generateReport(
        maData.fast, maData.slow, signals
    )
    
    // å›¾å½¢æ¸²æŸ“
    Renderer.GraphicsManager.renderMovingAverages(maData, CONFIG.STYLES, CONFIG.DISPLAY)
    Renderer.GraphicsManager.renderSignals(signals, CONFIG.STYLES, CONFIG.DISPLAY)
    Renderer.GraphicsManager.renderInfoPanel(analysis)
    
    // è¾“å‡ºç®¡ç†
    Renderer.OutputManager.setupOutput()
    Renderer.OutputManager.outputToTools(maData, CONFIG.STYLES, CONFIG)
    Renderer.OutputManager.outputAnalysis(analysis)
    
} catch (error) {
    O.print(`ç³»ç»Ÿé”™è¯¯: ${error.message}`, 'error')
    O.notify('æŒ‡æ ‡æ‰§è¡Œå¤±è´¥ï¼Œè¯·æ£€æŸ¥å‚æ•°è®¾ç½®', 'error')
}
```

### æ¨¡å—åŒ–ç»„ä»¶è®¾è®¡

#### å¯å¤ç”¨ç»„ä»¶åº“
```javascript
// é€šç”¨ç»„ä»¶åº“è®¾è®¡
const ComponentLibrary = {
    // ä¿¡å·ç”Ÿæˆå™¨ç»„ä»¶
    SignalGenerator: {
        create: function(type, config = {}) {
            const generators = {
                'cross': this.createCrossSignal,
                'threshold': this.createThresholdSignal,
                'pattern': this.createPatternSignal,
                'volume': this.createVolumeSignal
            }
            
            if (!generators[type]) {
                throw new Error(`æœªçŸ¥ä¿¡å·ç±»å‹: ${type}`)
            }
            
            return generators[type](config)
        },
        
        createCrossSignal: function(config) {
            return {
                generate: function(line1, line2, direction = 'both') {
                    const results = {}
                    
                    if (direction === 'up' || direction === 'both') {
                        results.up = F.throughUp(line1, line2)
                    }
                    
                    if (direction === 'down' || direction === 'both') {
                        results.down = F.throughDown(line1, line2)
                    }
                    
                    return results
                },
                
                filter: function(signals, filterConfig) {
                    // é€šç”¨ä¿¡å·è¿‡æ»¤é€»è¾‘
                    return signals.map((signal, index) => {
                        if (!signal) return null
                        
                        // åº”ç”¨å„ç§è¿‡æ»¤å™¨
                        if (filterConfig.minDistance) {
                            // è·ç¦»è¿‡æ»¤é€»è¾‘
                        }
                        
                        if (filterConfig.volumeFilter) {
                            // æˆäº¤é‡è¿‡æ»¤é€»è¾‘  
                        }
                        
                        return signal
                    })
                }
            }
        },
        
        createThresholdSignal: function(config) {
            return {
                generate: function(data, upperThreshold, lowerThreshold) {
                    return {
                        overbought: data.map(val => val > upperThreshold ? val : null),
                        oversold: data.map(val => val < lowerThreshold ? val : null)
                    }
                }
            }
        }
    },
    
    // æ ·å¼ç®¡ç†å™¨ç»„ä»¶
    StyleManager: {
        createTheme: function(themeName) {
            const themes = {
                'dark': {
                    primary: '#FF6D00',
                    secondary: '#2196F3', 
                    success: '#4CAF50',
                    danger: '#F44336',
                    background: 'rgba(0,0,0,0.8)'
                },
                'light': {
                    primary: '#FF9800',
                    secondary: '#3F51B5',
                    success: '#8BC34A', 
                    danger: '#E91E63',
                    background: 'rgba(255,255,255,0.9)'
                }
            }
            
            return themes[themeName] || themes['dark']
        },
        
        createStyleSet: function(theme, config = {}) {
            return {
                primaryLine: S.line(theme.primary, config.lineWidth || 2, 'solid'),
                secondaryLine: S.line(theme.secondary, config.lineWidth || 1, 'solid'),
                successSignal: S.shape('arrowUp', theme.success, config.signalSize || 12, 'lowDown'),
                dangerSignal: S.shape('arrowDown', theme.danger, config.signalSize || 12, 'highUp'),
                backgroundFill: S.area(theme.background, true)
            }
        }
    },
    
    // æ•°æ®å¤„ç†å™¨ç»„ä»¶
    DataProcessor: {
        create: function(type) {
            const processors = {
                'smoother': this.createSmoother,
                'normalizer': this.createNormalizer,
                'validator': this.createValidator,
                'aggregator': this.createAggregator
            }
            
            return processors[type]?.() || null
        },
        
        createSmoother: function() {
            return {
                smooth: function(data, method = 'ema', period = 3) {
                    switch(method) {
                        case 'ema':
                            return F.ema(data, period)
                        case 'sma':
                            return F.sma(data, period)  
                        case 'median':
                            return this.medianSmooth(data, period)
                        default:
                            return data
                    }
                },
                
                medianSmooth: function(data, period) {
                    return data.map((val, index) => {
                        if (index < period - 1) return null
                        
                        const window = data.slice(index - period + 1, index + 1)
                        const validWindow = window.filter(v => U.isValidNumber(v))
                        
                        if (validWindow.length === 0) return null
                        
                        validWindow.sort((a, b) => a - b)
                        const mid = Math.floor(validWindow.length / 2)
                        
                        return validWindow.length % 2 === 0 
                            ? (validWindow[mid - 1] + validWindow[mid]) / 2
                            : validWindow[mid]
                    })
                }
            }
        }
    }
}

// ç»„ä»¶ä½¿ç”¨ç¤ºä¾‹
const crossGenerator = ComponentLibrary.SignalGenerator.create('cross')
const darkTheme = ComponentLibrary.StyleManager.createTheme('dark')
const smoother = ComponentLibrary.DataProcessor.create('smoother')

// ä½¿ç”¨ç»„ä»¶å¼€å‘æŒ‡æ ‡
const fastMA = smoother.smooth(F.attr(dataList, 'close'), 'ema', 5)
const slowMA = smoother.smooth(F.attr(dataList, 'close'), 'ema', 20)
const signals = crossGenerator.generate(fastMA, slowMA)
const styles = ComponentLibrary.StyleManager.createStyleSet(darkTheme)
```

## âš¡ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### è®¡ç®—æ€§èƒ½ä¼˜åŒ–

#### ç¼“å­˜æœºåˆ¶å®ç°
```javascript
// é«˜çº§ç¼“å­˜ç³»ç»Ÿ
const AdvancedCache = {
    cache: new Map(),
    maxSize: 100,
    statistics: {
        hits: 0,
        misses: 0,
        computeTime: 0
    },
    
    // ç”Ÿæˆç¼“å­˜é”®
    generateKey: function(methodName, params) {
        const keyParts = [methodName]
        
        if (Array.isArray(params)) {
            keyParts.push(...params.map(p => {
                if (typeof p === 'object') {
                    return JSON.stringify(p)
                }
                return String(p)
            }))
        }
        
        return keyParts.join('_')
    },
    
    // è·å–ç¼“å­˜
    get: function(key) {
        if (this.cache.has(key)) {
            this.statistics.hits++
            const entry = this.cache.get(key)
            entry.lastAccessed = Date.now()
            return entry.value
        }
        
        this.statistics.misses++
        return null
    },
    
    // è®¾ç½®ç¼“å­˜
    set: function(key, value, computeTime = 0) {
        // ç¼“å­˜å¤§å°ç®¡ç†
        if (this.cache.size >= this.maxSize) {
            this.evictLRU()
        }
        
        this.cache.set(key, {
            value: value,
            created: Date.now(),
            lastAccessed: Date.now(),
            computeTime: computeTime
        })
        
        this.statistics.computeTime += computeTime
    },
    
    // LRUæ·˜æ±°ç­–ç•¥
    evictLRU: function() {
        let oldestKey = null
        let oldestTime = Infinity
        
        for (const [key, entry] of this.cache.entries()) {
            if (entry.lastAccessed < oldestTime) {
                oldestTime = entry.lastAccessed
                oldestKey = key
            }
        }
        
        if (oldestKey) {
            this.cache.delete(oldestKey)
        }
    },
    
    // ç¼“å­˜è£…é¥°å™¨
    memoize: function(fn, keyGenerator) {
        return (...args) => {
            const key = keyGenerator ? keyGenerator(...args) : this.generateKey(fn.name, args)
            let result = this.get(key)
            
            if (result === null) {
                const startTime = Date.now()
                result = fn(...args)
                const computeTime = Date.now() - startTime
                
                this.set(key, result, computeTime)
            }
            
            return result
        }
    },
    
    // æ€§èƒ½ç»Ÿè®¡
    getStats: function() {
        const totalRequests = this.statistics.hits + this.statistics.misses
        return {
            hitRate: totalRequests > 0 ? (this.statistics.hits / totalRequests * 100).toFixed(1) + '%' : '0%',
            totalRequests: totalRequests,
            cacheSize: this.cache.size,
            avgComputeTime: this.statistics.misses > 0 ? (this.statistics.computeTime / this.statistics.misses).toFixed(1) + 'ms' : '0ms'
        }
    }
}

// ä½¿ç”¨ç¼“å­˜è£…é¥°å™¨ä¼˜åŒ–è®¡ç®—
const cachedMA = AdvancedCache.memoize(
    (data, period, source) => F.ma(data, period, source),
    (data, period, source) => `ma_${period}_${source}_${data.length}`
)

const cachedRSI = AdvancedCache.memoize(
    (data, period) => F.rsi(data, period),
    (data, period) => `rsi_${period}_${data.length}`
)

// ä½¿ç”¨ç¤ºä¾‹
const ma20 = cachedMA(dataList, 20, 'close')  // é¦–æ¬¡è®¡ç®—
const ma20Again = cachedMA(dataList, 20, 'close')  // ä½¿ç”¨ç¼“å­˜

// è¾“å‡ºç¼“å­˜æ€§èƒ½ç»Ÿè®¡
const cacheStats = AdvancedCache.getStats()
O.print(`ç¼“å­˜å‘½ä¸­ç‡: ${cacheStats.hitRate}`)
O.print(`ç¼“å­˜å¤§å°: ${cacheStats.cacheSize}`)
```

#### æ‰¹é‡è®¡ç®—ä¼˜åŒ–
```javascript
// æ‰¹é‡è®¡ç®—ç®¡ç†å™¨
const BatchProcessor = {
    queue: [],
    isProcessing: false,
    results: new Map(),
    
    // æ·»åŠ è®¡ç®—ä»»åŠ¡
    addTask: function(id, calculator, priority = 0) {
        this.queue.push({
            id: id,
            calculator: calculator,
            priority: priority,
            timestamp: Date.now()
        })
        
        // æŒ‰ä¼˜å…ˆçº§æ’åº
        this.queue.sort((a, b) => b.priority - a.priority)
        
        if (!this.isProcessing) {
            this.process()
        }
    },
    
    // å¤„ç†é˜Ÿåˆ—
    process: function() {
        this.isProcessing = true
        
        while (this.queue.length > 0) {
            const task = this.queue.shift()
            
            try {
                const startTime = Date.now()
                const result = task.calculator()
                const processingTime = Date.now() - startTime
                
                this.results.set(task.id, {
                    data: result,
                    processingTime: processingTime,
                    completed: Date.now()
                })
                
                O.print(`æ‰¹é‡ä»»åŠ¡å®Œæˆ: ${task.id} (${processingTime}ms)`)
                
            } catch (error) {
                O.print(`æ‰¹é‡ä»»åŠ¡å¤±è´¥: ${task.id} - ${error.message}`, 'error')
                this.results.set(task.id, { error: error.message })
            }
        }
        
        this.isProcessing = false
    },
    
    // è·å–ç»“æœ
    getResult: function(id, timeout = 5000) {
        const startWait = Date.now()
        
        while (Date.now() - startWait < timeout) {
            if (this.results.has(id)) {
                return this.results.get(id)
            }
            
            // ç®€å•çš„ç­‰å¾…æœºåˆ¶ï¼ˆåœ¨å®é™…ç¯å¢ƒä¸­å¯èƒ½éœ€è¦æ›´ä¼˜é›…çš„å®ç°ï¼‰
            if (this.queue.some(task => task.id === id) || this.isProcessing) {
                continue
            } else {
                break
            }
        }
        
        return null
    },
    
    // æ‰¹é‡è®¡ç®—å¤šä¸ªæŒ‡æ ‡
    batchCalculate: function(calculations) {
        const taskIds = []
        
        calculations.forEach((calc, index) => {
            const taskId = `batch_${Date.now()}_${index}`
            this.addTask(taskId, calc.calculator, calc.priority || 0)
            taskIds.push(taskId)
        })
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        const results = {}
        taskIds.forEach((taskId, index) => {
            const result = this.getResult(taskId)
            if (result && !result.error) {
                results[calculations[index].name || `task_${index}`] = result.data
            }
        })
        
        return results
    }
}

// ä½¿ç”¨æ‰¹é‡å¤„ç†å™¨
const batchResults = BatchProcessor.batchCalculate([
    {
        name: 'ma5',
        calculator: () => F.ma(dataList, 5, 'close'),
        priority: 3
    },
    {
        name: 'ma20', 
        calculator: () => F.ma(dataList, 20, 'close'),
        priority: 2
    },
    {
        name: 'rsi14',
        calculator: () => F.rsi(dataList, 14),
        priority: 1
    },
    {
        name: 'macd',
        calculator: () => F.macd(dataList, 12, 26, 9),
        priority: 1
    }
])

// ä½¿ç”¨æ‰¹é‡è®¡ç®—ç»“æœ
if (batchResults.ma5 && batchResults.ma20) {
    const crossSignals = F.throughUp(batchResults.ma5, batchResults.ma20)
    D.shape(crossSignals, S.shape('arrowUp', '#00FF00', 12, 'lowDown'))
}
```

### å†…å­˜ç®¡ç†ä¼˜åŒ–

#### å¯¹è±¡æ± æ¨¡å¼
```javascript
// å¯¹è±¡æ± ç®¡ç†å™¨
const ObjectPool = {
    pools: new Map(),
    
    // åˆ›å»ºå¯¹è±¡æ± 
    createPool: function(type, factory, resetFn, initialSize = 10) {
        const pool = {
            objects: [],
            factory: factory,
            reset: resetFn,
            created: 0,
            reused: 0
        }
        
        // é¢„åˆ›å»ºå¯¹è±¡
        for (let i = 0; i < initialSize; i++) {
            pool.objects.push(factory())
            pool.created++
        }
        
        this.pools.set(type, pool)
        return pool
    },
    
    // è·å–å¯¹è±¡
    acquire: function(type) {
        const pool = this.pools.get(type)
        if (!pool) {
            throw new Error(`å¯¹è±¡æ± ä¸å­˜åœ¨: ${type}`)
        }
        
        let obj
        if (pool.objects.length > 0) {
            obj = pool.objects.pop()
            pool.reused++
        } else {
            obj = pool.factory()
            pool.created++
        }
        
        return obj
    },
    
    // é‡Šæ”¾å¯¹è±¡
    release: function(type, obj) {
        const pool = this.pools.get(type)
        if (!pool) return
        
        // é‡ç½®å¯¹è±¡çŠ¶æ€
        if (pool.reset) {
            pool.reset(obj)
        }
        
        pool.objects.push(obj)
    },
    
    // æ± çŠ¶æ€ç»Ÿè®¡
    getPoolStats: function(type) {
        const pool = this.pools.get(type)
        if (!pool) return null
        
        return {
            available: pool.objects.length,
            created: pool.created,
            reused: pool.reused,
            reuseRate: pool.created > 0 ? (pool.reused / pool.created * 100).toFixed(1) + '%' : '0%'
        }
    }
}

// åˆ›å»ºè®¡ç®—ç»“æœå¯¹è±¡æ± 
ObjectPool.createPool(
    'calculationResult',
    () => ({ values: [], metadata: {}, timestamp: 0 }),
    (obj) => {
        obj.values.length = 0
        obj.metadata = {}
        obj.timestamp = 0
    }
)

// åˆ›å»ºæ ·å¼å¯¹è±¡æ± 
ObjectPool.createPool(
    'styleObject',
    () => ({ color: '', size: 0, style: '', show: true }),
    (obj) => {
        obj.color = ''
        obj.size = 0
        obj.style = ''
        obj.show = true
    }
)

// ä½¿ç”¨å¯¹è±¡æ± 
function calculateWithPool(data, period) {
    const result = ObjectPool.acquire('calculationResult')
    
    try {
        result.values = F.ma(data, period, 'close')
        result.metadata.period = period
        result.metadata.dataLength = data.length
        result.timestamp = Date.now()
        
        // å¤„ç†ç»“æœ...
        const processedData = [...result.values]
        
        return processedData
        
    } finally {
        // ç¡®ä¿å¯¹è±¡è¢«é‡Šæ”¾å›æ± ä¸­
        ObjectPool.release('calculationResult', result)
    }
}

// ç›‘æ§å¯¹è±¡æ± æ€§èƒ½
O.print('å¯¹è±¡æ± ç»Ÿè®¡:')
const calcStats = ObjectPool.getPoolStats('calculationResult')
if (calcStats) {
    O.print(`è®¡ç®—ç»“æœæ±  - å¯ç”¨: ${calcStats.available}, å¤ç”¨ç‡: ${calcStats.reuseRate}`)
}
```

## ğŸ¨ è®¾è®¡æ¨¡å¼åº”ç”¨

### ç­–ç•¥æ¨¡å¼å®ç°

#### ç®—æ³•ç­–ç•¥ç®¡ç†å™¨
```javascript
// ç­–ç•¥æ¨¡å¼ - ç®—æ³•é€‰æ‹©ç³»ç»Ÿ
const AlgorithmStrategy = {
    strategies: new Map(),
    
    // æ³¨å†Œç­–ç•¥
    register: function(name, strategy) {
        if (typeof strategy.execute !== 'function') {
            throw new Error('ç­–ç•¥å¿…é¡»åŒ…å«executeæ–¹æ³•')
        }
        
        this.strategies.set(name, {
            ...strategy,
            name: name,
            registered: Date.now()
        })
    },
    
    // æ‰§è¡Œç­–ç•¥
    execute: function(strategyName, context) {
        const strategy = this.strategies.get(strategyName)
        if (!strategy) {
            throw new Error(`ç­–ç•¥ä¸å­˜åœ¨: ${strategyName}`)
        }
        
        // éªŒè¯ä¸Šä¸‹æ–‡
        if (strategy.validate && !strategy.validate(context)) {
            throw new Error(`ç­–ç•¥${strategyName}çš„ä¸Šä¸‹æ–‡éªŒè¯å¤±è´¥`)
        }
        
        return strategy.execute(context)
    },
    
    // è·å–å¯ç”¨ç­–ç•¥
    getAvailableStrategies: function() {
        return Array.from(this.strategies.keys())
    },
    
    // ç­–ç•¥æ€§èƒ½æ¯”è¾ƒ
    benchmark: function(strategies, context, iterations = 1) {
        const results = {}
        
        strategies.forEach(strategyName => {
            const startTime = Date.now()
            
            for (let i = 0; i < iterations; i++) {
                this.execute(strategyName, context)
            }
            
            const endTime = Date.now()
            results[strategyName] = {
                totalTime: endTime - startTime,
                avgTime: (endTime - startTime) / iterations
            }
        })
        
        return results
    }
}

// æ³¨å†Œç§»åŠ¨å¹³å‡ç­–ç•¥
AlgorithmStrategy.register('sma', {
    description: 'ç®€å•ç§»åŠ¨å¹³å‡',
    validate: (ctx) => ctx.data && ctx.period > 0,
    execute: (ctx) => F.ma(ctx.data, ctx.period, ctx.source || 'close'),
    parameters: ['data', 'period', 'source?']
})

AlgorithmStrategy.register('ema', {
    description: 'æŒ‡æ•°ç§»åŠ¨å¹³å‡',
    validate: (ctx) => ctx.data && ctx.period > 0,
    execute: (ctx) => F.ema(ctx.data, ctx.period, ctx.source || 'close'),
    parameters: ['data', 'period', 'source?']
})

AlgorithmStrategy.register('wma', {
    description: 'åŠ æƒç§»åŠ¨å¹³å‡',
    validate: (ctx) => ctx.data && ctx.period > 0,
    execute: (ctx) => F.wma(ctx.data, ctx.period, ctx.source || 'close'),
    parameters: ['data', 'period', 'source?']
})

AlgorithmStrategy.register('adaptive', {
    description: 'è‡ªé€‚åº”ç§»åŠ¨å¹³å‡',
    validate: (ctx) => ctx.data && ctx.period > 0,
    execute: (ctx) => {
        // æ ¹æ®æ³¢åŠ¨ç‡é€‰æ‹©ç®—æ³•
        const volatility = F.std(ctx.data, ctx.period)
        const avgVolatility = U.avg(volatility.filter(v => U.isValidNumber(v)))
        
        if (avgVolatility > ctx.highVolatilityThreshold || 0.02) {
            return F.ema(ctx.data, Math.floor(ctx.period * 0.7), ctx.source || 'close')
        } else {
            return F.sma(ctx.data, ctx.period, ctx.source || 'close')
        }
    },
    parameters: ['data', 'period', 'source?', 'highVolatilityThreshold?']
})

// ä½¿ç”¨ç­–ç•¥ç³»ç»Ÿ
const algorithmType = I.select('adaptive', 
    AlgorithmStrategy.getAvailableStrategies(), 
    'ç®—æ³•é€‰æ‹©', 'é€‰æ‹©ç§»åŠ¨å¹³å‡ç®—æ³•')

const period = I.int(20, 'å‘¨æœŸ', 1, 200)
const source = I.select('close', SOURCE, 'æ•°æ®æº')

// æ‰§è¡Œé€‰å®šçš„ç­–ç•¥
const context = {
    data: dataList,
    period: period,
    source: source,
    highVolatilityThreshold: 0.015
}

const result = AlgorithmStrategy.execute(algorithmType, context)

// ç­–ç•¥æ€§èƒ½æ¯”è¾ƒï¼ˆå¼€å‘æ¨¡å¼ï¼‰
if (I.bool(false, 'æ€§èƒ½æ¯”è¾ƒ', 'å¼€å‘è®¾ç½®')) {
    const benchmark = AlgorithmStrategy.benchmark(
        ['sma', 'ema', 'wma', 'adaptive'], 
        context, 
        5
    )
    
    O.print('ç®—æ³•æ€§èƒ½æ¯”è¾ƒ:')
    Object.entries(benchmark).forEach(([name, stats]) => {
        O.print(`${name}: ${stats.avgTime.toFixed(2)}mså¹³å‡`)
    })
}
```

### è§‚å¯Ÿè€…æ¨¡å¼å®ç°

#### äº‹ä»¶é©±åŠ¨ç³»ç»Ÿ
```javascript
// è§‚å¯Ÿè€…æ¨¡å¼ - äº‹ä»¶ç³»ç»Ÿ
const EventSystem = {
    listeners: new Map(),
    eventHistory: [],
    maxHistorySize: 100,
    
    // æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
    on: function(eventType, callback, options = {}) {
        if (!this.listeners.has(eventType)) {
            this.listeners.set(eventType, [])
        }
        
        const listener = {
            callback: callback,
            once: options.once || false,
            priority: options.priority || 0,
            id: `${eventType}_${Date.now()}_${Math.random()}`
        }
        
        this.listeners.get(eventType).push(listener)
        
        // æŒ‰ä¼˜å…ˆçº§æ’åº
        this.listeners.get(eventType).sort((a, b) => b.priority - a.priority)
        
        return listener.id
    },
    
    // å–æ¶ˆç›‘å¬å™¨
    off: function(eventType, listenerId) {
        if (!this.listeners.has(eventType)) return
        
        const listeners = this.listeners.get(eventType)
        const index = listeners.findIndex(l => l.id === listenerId)
        
        if (index !== -1) {
            listeners.splice(index, 1)
        }
    },
    
    // è§¦å‘äº‹ä»¶
    emit: function(eventType, data = {}) {
        const event = {
            type: eventType,
            data: data,
            timestamp: Date.now(),
            propagationStopped: false
        }
        
        // è®°å½•äº‹ä»¶å†å²
        this.eventHistory.push(event)
        if (this.eventHistory.length > this.maxHistorySize) {
            this.eventHistory.shift()
        }
        
        if (!this.listeners.has(eventType)) return event
        
        const listeners = this.listeners.get(eventType)
        const toRemove = []
        
        for (const listener of listeners) {
            if (event.propagationStopped) break
            
            try {
                const result = listener.callback(event)
                
                // æ”¯æŒé˜»æ­¢äº‹ä»¶ä¼ æ’­
                if (result === false) {
                    event.propagationStopped = true
                }
                
            } catch (error) {
                O.print(`äº‹ä»¶ç›‘å¬å™¨é”™è¯¯ [${eventType}]: ${error.message}`, 'error')
            }
            
            // æ ‡è®°ä¸€æ¬¡æ€§ç›‘å¬å™¨ç”¨äºç§»é™¤
            if (listener.once) {
                toRemove.push(listener.id)
            }
        }
        
        // ç§»é™¤ä¸€æ¬¡æ€§ç›‘å¬å™¨
        toRemove.forEach(id => this.off(eventType, id))
        
        return event
    },
    
    // è·å–äº‹ä»¶å†å²
    getHistory: function(eventType) {
        if (eventType) {
            return this.eventHistory.filter(e => e.type === eventType)
        }
        return [...this.eventHistory]
    }
}

// å®šä¹‰åº”ç”¨äº‹ä»¶
const AppEvents = {
    DATA_LOADED: 'data:loaded',
    CALCULATION_START: 'calculation:start', 
    CALCULATION_COMPLETE: 'calculation:complete',
    SIGNAL_GENERATED: 'signal:generated',
    ERROR_OCCURRED: 'error:occurred',
    PARAMETER_CHANGED: 'parameter:changed'
}

// æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
EventSystem.on(AppEvents.CALCULATION_START, (event) => {
    O.print(`å¼€å§‹è®¡ç®—: ${event.data.type}`)
})

EventSystem.on(AppEvents.CALCULATION_COMPLETE, (event) => {
    O.print(`è®¡ç®—å®Œæˆ: ${event.data.type} (${event.data.duration}ms)`)
})

EventSystem.on(AppEvents.SIGNAL_GENERATED, (event) => {
    const signal = event.data
    O.print(`ä¿¡å·ç”Ÿæˆ: ${signal.type} at index ${signal.index}`)
    
    // å¯ä»¥è§¦å‘é€šçŸ¥
    if (signal.strength > 0.8) {
        O.notify(`å¼ºä¿¡å·: ${signal.type}`, signal.type === 'buy' ? 'success' : 'warning')
    }
})

EventSystem.on(AppEvents.ERROR_OCCURRED, (event) => {
    O.print(`é”™è¯¯å‘ç”Ÿ: ${event.data.message}`, 'error')
    O.log(`é”™è¯¯è¯¦æƒ…: ${JSON.stringify(event.data)}`, 'error')
}, { priority: 10 })  // é«˜ä¼˜å…ˆçº§

// åœ¨è®¡ç®—ä¸­ä½¿ç”¨äº‹ä»¶ç³»ç»Ÿ
function calculateWithEvents(data, period) {
    EventSystem.emit(AppEvents.CALCULATION_START, {
        type: 'MA',
        period: period,
        dataLength: data.length
    })
    
    const startTime = Date.now()
    
    try {
        const result = F.ma(data, period, 'close')
        const duration = Date.now() - startTime
        
        EventSystem.emit(AppEvents.CALCULATION_COMPLETE, {
            type: 'MA',
            period: period,
            duration: duration,
            resultLength: result.length
        })
        
        return result
        
    } catch (error) {
        EventSystem.emit(AppEvents.ERROR_OCCURRED, {
            type: 'calculation_error',
            method: 'F.ma',
            message: error.message,
            parameters: { period: period }
        })
        
        throw error
    }
}

// ä¿¡å·æ£€æµ‹ä¸äº‹ä»¶
function detectSignalsWithEvents(fastMA, slowMA) {
    const buySignals = F.throughUp(fastMA, slowMA)
    const sellSignals = F.throughDown(fastMA, slowMA)
    
    // ä¸ºæ¯ä¸ªä¿¡å·è§¦å‘äº‹ä»¶
    buySignals.forEach((signal, index) => {
        if (signal !== null) {
            EventSystem.emit(AppEvents.SIGNAL_GENERATED, {
                type: 'buy',
                index: index,
                value: signal.val1,
                strength: Math.abs(signal.val1 - signal.val2) / signal.val2
            })
        }
    })
    
    sellSignals.forEach((signal, index) => {
        if (signal !== null) {
            EventSystem.emit(AppEvents.SIGNAL_GENERATED, {
                type: 'sell', 
                index: index,
                value: signal.val1,
                strength: Math.abs(signal.val1 - signal.val2) / signal.val2
            })
        }
    })
    
    return { buy: buySignals, sell: sellSignals }
}
```

## ğŸ“ ç¼–ç è§„èŒƒå’Œè´¨é‡æ ‡å‡†

### å‘½åçº¦å®šæ ‡å‡†

#### ç»Ÿä¸€å‘½åè§„èŒƒ
```javascript
// GainLab Script å‘½åè§„èŒƒæŒ‡å—

// =====================================
// 1. å˜é‡å‘½åè§„èŒƒ
// =====================================

// âœ… æ¨èï¼šä½¿ç”¨é©¼å³°å‘½åæ³•
const fastPeriod = I.int(5, 'å¿«çº¿å‘¨æœŸ')
const slowPeriod = I.int(20, 'æ…¢çº¿å‘¨æœŸ')  
const showSignals = I.bool(true, 'æ˜¾ç¤ºä¿¡å·')

// âœ… æ¨èï¼šå¸ƒå°”å€¼ä½¿ç”¨is/has/can/shouldå‰ç¼€
const isValidData = U.isValid(dataList)
const hasEnoughData = dataList.length >= 50
const canCalculateMA = isValidData && hasEnoughData
const shouldShowWarning = !hasEnoughData

// âœ… æ¨èï¼šå¸¸é‡ä½¿ç”¨å¤§å†™åŠ ä¸‹åˆ’çº¿
const DEFAULT_PERIOD = 20
const MIN_DATA_LENGTH = 50
const MAX_SIGNAL_DISTANCE = 0.05

// âŒ é¿å…ï¼šä¸æ¸…æ™°çš„å‘½å
// const p = 20              // ä¸æ¸…æ™°
// const data = []           // å¤ªé€šç”¨
// const temp = calculate()  // ä¸´æ—¶å˜é‡å

// =====================================
// 2. å‡½æ•°å‘½åè§„èŒƒ  
// =====================================

// âœ… æ¨èï¼šåŠ¨è¯å¼€å¤´ï¼Œæè¿°åŠŸèƒ½
function calculateMovingAverage(data, period) { }
function validateInputParameters(config) { }
function generateTradingSignals(fastMA, slowMA) { }
function renderChartElements(data, styles) { }

// âœ… æ¨èï¼šè¿”å›å¸ƒå°”å€¼çš„å‡½æ•°ä½¿ç”¨is/has/canå‰ç¼€
function isDataValid(data) {
    return data && Array.isArray(data) && data.length > 0
}

function hasValidPrice(kline) {
    return kline && U.isValidNumber(kline.close)
}

function canExecuteStrategy(context) {
    return isDataValid(context.data) && hasValidPrice(context.data[0])
}

// =====================================
// 3. å¯¹è±¡å’Œç±»å‘½åè§„èŒƒ
// =====================================

// âœ… æ¨èï¼šä½¿ç”¨PascalCaseå‘½åå¯¹è±¡æ„é€ å™¨/ç±»
const SignalAnalyzer = {
    analyze: function(signals) { },
    generateReport: function(analysis) { }
}

const TrendDetector = {
    detectTrend: function(data) { },
    getTrendStrength: function(trend) { }
}

// âœ… æ¨èï¼šé…ç½®å¯¹è±¡ä½¿ç”¨æè¿°æ€§åç§°
const IndicatorConfig = {
    periods: {
        fast: 5,
        slow: 20,
        signal: 9
    },
    display: {
        showLines: true,
        showSignals: true,
        showFill: false
    },
    thresholds: {
        overbought: 70,
        oversold: 30,
        signalStrength: 0.5
    }
}

// =====================================
// 4. æ ·å¼å¯¹è±¡å‘½åè§„èŒƒ
// =====================================

// âœ… æ¨èï¼šæ ·å¼åç§°åŒ…å«å…ƒç´ ç±»å‹å’Œç”¨é€”
const fastLineStyle = S.line('#FF0000', 2, 'solid', title='å¿«çº¿æ ·å¼')
const slowLineStyle = S.line('#0000FF', 2, 'solid', title='æ…¢çº¿æ ·å¼')
const buySignalStyle = S.shape('arrowUp', '#00FF00', 12, 'lowDown', title='ä¹°å…¥ä¿¡å·')
const sellSignalStyle = S.shape('arrowDown', '#FF0000', 12, 'highUp', title='å–å‡ºä¿¡å·')
const overboughtLineStyle = S.line('#FF4444', 1, 'dashed', title='è¶…ä¹°çº¿')

// =====================================
// 5. ç‰¹æ®Šå‘½åçº¦å®š
// =====================================

// æ•°ç»„/åˆ—è¡¨ä½¿ç”¨å¤æ•°æˆ–æ˜ç¡®çš„åç¼€
const prices = F.attr(dataList, 'close')
const volumes = F.attr(dataList, 'volume') 
const signalList = []
const calculationResults = []

// ç´¢å¼•ä½¿ç”¨indexæˆ–æ˜ç¡®çš„åç§°
dataList.forEach((kline, klineIndex) => {
    // å¤„ç†æ¯æ ¹Kçº¿
})

const currentIndex = dataList.length - 1
const startIndex = Math.max(0, currentIndex - lookbackPeriod)

// ä¸´æ—¶å˜é‡ä½¿ç”¨tempå‰ç¼€ï¼ˆå°½é‡é¿å…ï¼‰
const tempCalculation = someComplexCalculation()
const processedData = processTemporaryData(tempCalculation)
```

### ä»£ç ç»“æ„è§„èŒƒ

#### æ ‡å‡†æ–‡ä»¶ç»“æ„æ¨¡æ¿
```javascript
//@name=æ ‡å‡†ç»“æ„æ¨¡æ¿
//@title=Standard Structure Template æ ‡å‡†ç»“æ„æ¨¡æ¿
//@desc=## æ ‡å‡†GainLab Scriptç»“æ„æ¨¡æ¿
//å±•ç¤ºæ¨èçš„ä»£ç ç»„ç»‡ç»“æ„å’Œæœ€ä½³å®è·µ
//#### ç‰¹ç‚¹ï¼š
//- **æ¸…æ™°åˆ†å±‚** - é€»è¾‘åˆ†ç¦»ï¼ŒèŒè´£æ˜ç¡®
//- **æ ‡å‡†è§„èŒƒ** - éµå¾ªæœ€ä½³å®è·µ
//- **æ˜“äºç»´æŠ¤** - æ¨¡å—åŒ–è®¾è®¡
//@position=main
//@version=1

// =====================================
// ç¬¬ä¸€éƒ¨åˆ†ï¼šå¯¼å…¥å’Œä¾èµ– (å¦‚æœæœ‰å¤–éƒ¨ä¾èµ–)
// =====================================

// è¿™é‡Œå¯ä»¥å®šä¹‰ä¸€äº›å·¥å…·å‡½æ•°æˆ–å¯¼å…¥å¤–éƒ¨æ¨¡å—
// æ³¨æ„ï¼šGainLab Scriptç›®å‰ä¸æ”¯æŒçœŸæ­£çš„æ¨¡å—å¯¼å…¥

// =====================================
// ç¬¬äºŒéƒ¨åˆ†ï¼šå¸¸é‡å®šä¹‰
// =====================================

// ä¸šåŠ¡å¸¸é‡
const DEFAULT_PERIODS = {
    FAST: 5,
    SLOW: 20, 
    SIGNAL: 9
}

const SIGNAL_THRESHOLDS = {
    STRONG_BUY: 0.8,
    BUY: 0.6,
    SELL: 0.4,
    STRONG_SELL: 0.2
}

const DISPLAY_CONFIG = {
    MAX_SIGNALS_DISPLAY: 50,
    LABEL_FREQUENCY: 10,
    INFO_PANEL_POSITION: { x: 20, y: 20 }
}

// =====================================
// ç¬¬ä¸‰éƒ¨åˆ†ï¼šè¾“å…¥å‚æ•°å®šä¹‰ (Iæ–¹æ³•åŒºåŸŸ)
// =====================================

// åŸºç¡€å‚æ•°ç»„
const fastPeriod = I.int(DEFAULT_PERIODS.FAST, 'å¿«çº¿å‘¨æœŸ', 1, 50, 1, 'åŸºç¡€å‚æ•°', 'å¿«é€Ÿç§»åŠ¨å¹³å‡å‘¨æœŸ')
const slowPeriod = I.int(DEFAULT_PERIODS.SLOW, 'æ…¢çº¿å‘¨æœŸ', 5, 200, 1, 'åŸºç¡€å‚æ•°', 'æ…¢é€Ÿç§»åŠ¨å¹³å‡å‘¨æœŸ')
const source = I.select('close', SOURCE, 'æ•°æ®æº', 'åŸºç¡€å‚æ•°', 'è®¡ç®—æ•°æ®æº')

// æ˜¾ç¤ºæ§åˆ¶ç»„
const showMA = I.bool(true, 'æ˜¾ç¤ºå‡çº¿', 'æ˜¾ç¤ºæ§åˆ¶', 'æ˜¯å¦æ˜¾ç¤ºç§»åŠ¨å¹³å‡çº¿')
const showSignals = I.bool(true, 'æ˜¾ç¤ºä¿¡å·', 'æ˜¾ç¤ºæ§åˆ¶', 'æ˜¯å¦æ˜¾ç¤ºäº¤å‰ä¿¡å·')  
const showFill = I.bool(false, 'æ˜¾ç¤ºå¡«å……', 'æ˜¾ç¤ºæ§åˆ¶', 'æ˜¯å¦æ˜¾ç¤ºå‡çº¿é—´å¡«å……')
const showInfoPanel = I.bool(true, 'æ˜¾ç¤ºä¿¡æ¯é¢æ¿', 'æ˜¾ç¤ºæ§åˆ¶', 'æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯é¢æ¿')

// é«˜çº§å‚æ•°ç»„
const signalFilter = I.bool(true, 'å¯ç”¨ä¿¡å·è¿‡æ»¤', 'é«˜çº§è®¾ç½®', 'å¯ç”¨æ™ºèƒ½ä¿¡å·è¿‡æ»¤')
const minDistance = I.float(0.5, 'æœ€å°è·ç¦»%', 0.1, 5.0, 0.1, 'é«˜çº§è®¾ç½®', 'ä¿¡å·è§¦å‘æœ€å°è·ç¦»ç™¾åˆ†æ¯”')
const volumeThreshold = I.float(1.2, 'æˆäº¤é‡é˜ˆå€¼', 0.5, 3.0, 0.1, 'é«˜çº§è®¾ç½®', 'æˆäº¤é‡ç¡®è®¤é˜ˆå€¼')

// =====================================
// ç¬¬å››éƒ¨åˆ†ï¼šæ ·å¼å®šä¹‰ (Sæ–¹æ³•åŒºåŸŸ)
// =====================================

// ä¸»è¦çº¿æ¡æ ·å¼
const fastLineStyle = S.line('#FF0000', 2, 'solid', showMA, 'å¿«çº¿æ ·å¼')
const slowLineStyle = S.line('#0000FF', 2, 'solid', showMA, 'æ…¢çº¿æ ·å¼')

// ä¿¡å·æ ·å¼
const buySignalStyle = S.shape('arrowUp', '#00C851', 14, 'lowDown', 'fill', showSignals, 'ä¹°å…¥ä¿¡å·æ ·å¼')
const sellSignalStyle = S.shape('arrowDown', '#FF4444', 14, 'highUp', 'fill', showSignals, 'å–å‡ºä¿¡å·æ ·å¼')

// è¾…åŠ©æ ·å¼
const fillAreaStyle = S.area('rgba(255, 0, 0, 0.1)', showFill, 'å¡«å……åŒºåŸŸæ ·å¼')
const infoPanelTextStyle = S.slabel('#FFFFFF', 12, 'left', 'normal', 'ä¿¡æ¯é¢æ¿æ–‡å­—æ ·å¼')
const infoPanelBgStyle = S.labelbg('rgba(0, 0, 0, 0.8)', 'fill', 'ä¿¡æ¯é¢æ¿èƒŒæ™¯æ ·å¼')

// =====================================
// ç¬¬äº”éƒ¨åˆ†ï¼šå·¥å…·å‡½æ•°å®šä¹‰
// =====================================

// æ•°æ®éªŒè¯å‡½æ•°
function validateInputData(data, minLength) {
    if (!data || !Array.isArray(data)) {
        throw new Error('æ•°æ®æ ¼å¼é”™è¯¯ï¼šéœ€è¦æ•°ç»„æ ¼å¼')
    }
    
    if (data.length < minLength) {
        throw new Error(`æ•°æ®ä¸è¶³ï¼šéœ€è¦${minLength}æ¡ï¼Œå®é™…${data.length}æ¡`)
    }
    
    const validCount = data.filter(item => item && U.isValidNumber(item.close)).length
    if (validCount / data.length < 0.8) {
        O.print('è­¦å‘Šï¼šæ•°æ®è´¨é‡è¾ƒå·®ï¼Œå¯èƒ½å½±å“è®¡ç®—å‡†ç¡®æ€§', 'warn')
    }
    
    return true
}

// ä¿¡å·è¿‡æ»¤å‡½æ•°
function filterSignals(signals, fastMA, slowMA, config) {
    if (!config.enabled) return signals
    
    return signals.map((signal, index) => {
        if (signal === null) return null
        
        // è·ç¦»è¿‡æ»¤
        const distance = Math.abs(fastMA[index] - slowMA[index]) / slowMA[index] * 100
        if (distance < config.minDistance) return null
        
        // æˆäº¤é‡è¿‡æ»¤
        if (config.volumeFilter) {
            const kline = dataList[index]
            if (kline) {
                const avgVolume = getAverageVolume(index, 20)
                if (kline.volume < avgVolume * config.volumeThreshold) return null
            }
        }
        
        return signal
    })
}

// è·å–å¹³å‡æˆäº¤é‡
function getAverageVolume(currentIndex, lookback) {
    const startIndex = Math.max(0, currentIndex - lookback)
    const volumeSlice = dataList.slice(startIndex, currentIndex + 1)
    const volumes = volumeSlice.map(kline => kline.volume).filter(v => U.isValidNumber(v))
    return volumes.length > 0 ? U.avg(volumes) : 0
}

// ç”Ÿæˆåˆ†ææŠ¥å‘Š
function generateAnalysisReport(fastMA, slowMA, signals) {
    const currentFast = fastMA[fastMA.length - 1]
    const currentSlow = slowMA[slowMA.length - 1]
    
    const analysis = {
        trend: {
            direction: currentFast > currentSlow ? 'bullish' : 'bearish',
            strength: Math.abs(currentFast - currentSlow) / currentSlow * 100
        },
        signals: {
            buyCount: signals.buy.filter(s => s !== null).length,
            sellCount: signals.sell.filter(s => s !== null).length
        }
    }
    
    // ç”Ÿæˆå»ºè®®
    if (analysis.trend.direction === 'bullish' && analysis.trend.strength > 1.5) {
        analysis.recommendation = { action: 'buy', confidence: 0.75 }
    } else if (analysis.trend.direction === 'bearish' && analysis.trend.strength > 1.5) {
        analysis.recommendation = { action: 'sell', confidence: 0.75 }
    } else {
        analysis.recommendation = { action: 'hold', confidence: 0.5 }
    }
    
    return analysis
}

// =====================================
// ç¬¬å…­éƒ¨åˆ†ï¼šä¸»è¦è®¡ç®—é€»è¾‘
// =====================================

try {
    // 1. æ•°æ®éªŒè¯
    validateInputData(dataList, Math.max(fastPeriod, slowPeriod) + 10)
    
    // 2. æ ¸å¿ƒè®¡ç®—
    const fastMA = F.ma(dataList, fastPeriod, source)
    const slowMA = F.ma(dataList, slowPeriod, source)
    
    // éªŒè¯è®¡ç®—ç»“æœ
    if (!fastMA || !slowMA) {
        throw new Error('ç§»åŠ¨å¹³å‡è®¡ç®—å¤±è´¥')
    }
    
    // 3. ä¿¡å·æ£€æµ‹
    const rawBuySignals = F.throughUp(fastMA, slowMA)
    const rawSellSignals = F.throughDown(fastMA, slowMA)
    
    // 4. ä¿¡å·è¿‡æ»¤
    const filterConfig = {
        enabled: signalFilter,
        minDistance: minDistance,
        volumeFilter: true,
        volumeThreshold: volumeThreshold
    }
    
    const buySignals = filterSignals(rawBuySignals, fastMA, slowMA, filterConfig)
    const sellSignals = filterSignals(rawSellSignals, fastMA, slowMA, filterConfig)
    
    // 5. åˆ†ææŠ¥å‘Šç”Ÿæˆ
    const analysis = generateAnalysisReport(fastMA, slowMA, { buy: buySignals, sell: sellSignals })
    
    // =====================================
    // ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå›¾å½¢ç»˜åˆ¶ (Dæ–¹æ³•åŒºåŸŸ)
    // =====================================
    
    // ç»˜åˆ¶å¡«å……åŒºåŸŸï¼ˆå¦‚æœå¯ç”¨ï¼‰
    if (showFill) {
        D.area(fastMA, slowMA, fillAreaStyle)
    }
    
    // ç»˜åˆ¶ç§»åŠ¨å¹³å‡çº¿
    if (showMA) {
        D.line(fastMA, fastLineStyle)
        D.line(slowMA, slowLineStyle)
    }
    
    // ç»˜åˆ¶äº¤æ˜“ä¿¡å·
    if (showSignals) {
        D.shape(buySignals, buySignalStyle)
        D.shape(sellSignals, sellSignalStyle)
    }
    
    // ç»˜åˆ¶ä¿¡æ¯é¢æ¿
    if (showInfoPanel) {
        const panelInfo = [
            `è¶‹åŠ¿: ${analysis.trend.direction} (å¼ºåº¦: ${analysis.trend.strength.toFixed(2)}%)`,
            `ä¹°å…¥ä¿¡å·: ${analysis.signals.buyCount}ä¸ª`,
            `å–å‡ºä¿¡å·: ${analysis.signals.sellCount}ä¸ª`,
            `å»ºè®®: ${analysis.recommendation.action} (ç½®ä¿¡åº¦: ${(analysis.recommendation.confidence * 100).toFixed(0)}%)`
        ]
        
        panelInfo.forEach((text, index) => {
            D.slabel(
                DISPLAY_CONFIG.INFO_PANEL_POSITION.x,
                DISPLAY_CONFIG.INFO_PANEL_POSITION.y + index * 18,
                text,
                infoPanelTextStyle,
                infoPanelBgStyle
            )
        })
    }
    
    // =====================================
    // ç¬¬å…«éƒ¨åˆ†ï¼šæ•°æ®è¾“å‡º (Oæ–¹æ³•åŒºåŸŸ)
    // =====================================
    
    // è®¾ç½®ç²¾åº¦
    setPrecision('price')
    
    // è¾“å‡ºåˆ°å·¥å…·é¢æ¿
    if (showMA) {
        O.tools(`å¿«çº¿MA${fastPeriod}`, fastMA, fastLineStyle)
        O.tools(`æ…¢çº¿MA${slowPeriod}`, slowMA, slowLineStyle)
    }
    
    // è¾“å‡ºåˆ†æç»“æœ
    O.print('=== åŒå‡çº¿åˆ†ææŠ¥å‘Š ===')
    O.print(`å½“å‰è¶‹åŠ¿: ${analysis.trend.direction}`)
    O.print(`è¶‹åŠ¿å¼ºåº¦: ${analysis.trend.strength.toFixed(2)}%`)
    O.print(`äº¤æ˜“å»ºè®®: ${analysis.recommendation.action}`)
    O.print(`ç½®ä¿¡ç¨‹åº¦: ${(analysis.recommendation.confidence * 100).toFixed(0)}%`)
    
    // ä¿¡å·ç»Ÿè®¡
    O.print(`ä¹°å…¥ä¿¡å·: ${analysis.signals.buyCount}ä¸ª`)
    O.print(`å–å‡ºä¿¡å·: ${analysis.signals.sellCount}ä¸ª`)
    
    // æˆåŠŸå®Œæˆæç¤º
    O.print('âœ… æŒ‡æ ‡è®¡ç®—å®Œæˆ')
    
} catch (error) {
    // =====================================
    // ç¬¬ä¹éƒ¨åˆ†ï¼šé”™è¯¯å¤„ç†
    // =====================================
    
    O.print(`âŒ æŒ‡æ ‡æ‰§è¡Œå¤±è´¥: ${error.message}`, 'error')
    O.notify('æŒ‡æ ‡æ‰§è¡Œå‡ºé”™ï¼Œè¯·æ£€æŸ¥å‚æ•°è®¾ç½®', 'error')
    
    // æä¾›è¯Šæ–­ä¿¡æ¯
    O.print('=== è¯Šæ–­ä¿¡æ¯ ===')
    O.print(`æ•°æ®é•¿åº¦: ${dataList ? dataList.length : 'undefined'}`)
    O.print(`å¿«çº¿å‘¨æœŸ: ${fastPeriod}`)
    O.print(`æ…¢çº¿å‘¨æœŸ: ${slowPeriod}`)
    O.print(`æ•°æ®æº: ${source}`)
}

// =====================================
// ç¬¬åéƒ¨åˆ†ï¼šæ¸…ç†å’Œèµ„æºé‡Šæ”¾ï¼ˆå¦‚æœéœ€è¦ï¼‰
// =====================================

// åœ¨GainLab Scriptä¸­é€šå¸¸ä¸éœ€è¦æ˜¾å¼æ¸…ç†
// ä½†å¯ä»¥åœ¨è¿™é‡Œæ”¾ç½®ä¸€äº›æ¸…ç†ä»£ç ï¼Œå¦‚æ¸…ç†å…¨å±€å˜é‡ç­‰
```

## ğŸ”— ç›¸å…³å†…å®¹

- **åŸºç¡€çŸ¥è¯†**: [åŸºç¡€æ¦‚å¿µå’Œè„šæœ¬ç»“æ„](02-åŸºç¡€æ¦‚å¿µå’Œè„šæœ¬ç»“æ„.md) - æŒæ¡åŸºç¡€åå­¦ä¹ é«˜çº§æŠ€å·§
- **æ–¹æ³•è¯¦è§£**: [å„æ–¹æ³•è¯¦è§£](00-ä¸»ç´¢å¼•.md#æ–¹æ³•åˆ†ç±») - æ·±å…¥ç†è§£å„ç§æ–¹æ³•çš„é«˜çº§ç”¨æ³•
- **å®é™…æ¡ˆä¾‹**: [è„šæœ¬æ¡ˆä¾‹åº“](09-å®Œæ•´è„šæœ¬æ¡ˆä¾‹åº“.md) - æŸ¥çœ‹é«˜è´¨é‡ä»£ç ç¤ºä¾‹
- **é”™è¯¯å¤„ç†**: [é”™è¯¯å¤„ç†æŒ‡å—](10-é”™è¯¯å¤„ç†å’Œè°ƒè¯•æŒ‡å—.md) - é…åˆæœ€ä½³å®è·µé¿å…é”™è¯¯

---
**æç¤º**: é«˜çº§ä¸»é¢˜å’Œæœ€ä½³å®è·µæ˜¯ä»åˆçº§å‘ä¸“å®¶çº§è¿›é˜¶çš„å…³é”®ï¼Œå»ºè®®ç»“åˆå®é™…é¡¹ç›®é€æ­¥åº”ç”¨è¿™äº›æŠ€å·§å’Œæ¨¡å¼ï¼ŒæŒç»­æå‡ä»£ç è´¨é‡å’Œå¼€å‘æ•ˆç‡ã€‚