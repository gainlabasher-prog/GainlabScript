# U方法 - 工具函数

## 📋 U方法概述

**U方法（Util Method）**提供26个实用工具函数，涵盖数据验证、数学计算、数组处理、时间处理等常用功能，是GainLab Script开发的得力助手，提升代码质量和开发效率。

### 🎯 核心特点
- 🔍 **数据验证** - 提供全面的数据类型和有效性检查
- 🧮 **数学计算** - 常用数学运算函数，处理数值计算
- 📊 **数组处理** - 数组操作工具，简化数据处理流程
- ⏰ **时间处理** - 时间格式化和转换工具

### ⚠️ 核心约束
- **✅ 纯函数设计** - 不修改原始数据，返回新结果
- **✅ 异常安全** - 自动处理null、undefined等异常情况
- **✅ 性能优化** - 针对大数据量进行优化
- **✅ 类型兼容** - 支持多种数据类型输入

## 🗂️ U方法完整分类

### 🔍 数据验证类（8个方法）
| 方法 | 功能 | 返回类型 | 使用频率 |
|------|------|---------|---------|
| [U.isValid()](#U.isValid) | 检查数据有效性 | boolean | 🔥 极高 |
| [U.isValidNumber()](#U.isValidNumber) | 检查数值有效性 | boolean | 🔥 极高 |
| [U.isNull()](#U.isNull) | 检查null值 | boolean | 📊 高 |
| [U.isEmpty()](#U.isEmpty) | 检查空值 | boolean | 📊 高 |
| [U.isArray()](#U.isArray) | 检查数组类型 | boolean | 📝 中等 |
| [U.isObject()](#U.isObject) | 检查对象类型 | boolean | 📝 中等 |
| [U.isString()](#U.isString) | 检查字符串类型 | boolean | 📝 中等 |
| [U.isNumber()](#U.isNumber) | 检查数值类型 | boolean | 📝 中等 |

### 🧮 数学计算类（8个方法）
| 方法 | 功能 | 返回类型 | 使用频率 |
|------|------|---------|---------|
| [U.sum()](#U.sum) | 数组求和 | number | 🔥 极高 |
| [U.avg()](#U.avg) | 计算平均值 | number | 🔥 极高 |
| [U.max()](#U.max) | 获取最大值 | number | 📊 高 |
| [U.min()](#U.min) | 获取最小值 | number | 📊 高 |
| [U.abs()](#U.abs) | 计算绝对值 | number/array | 📊 高 |
| [U.round()](#U.round) | 四舍五入 | number/array | 📝 中等 |
| [U.floor()](#U.floor) | 向下取整 | number/array | 📝 中等 |
| [U.ceil()](#U.ceil) | 向上取整 | number/array | 📝 中等 |

### 📊 数组处理类（6个方法）
| 方法 | 功能 | 返回类型 | 使用频率 |
|------|------|---------|---------|
| [U.slice()](#U.slice) | 数组切片 | array | 📊 高 |
| [U.filter()](#U.filter) | 数组过滤 | array | 📊 高 |
| [U.map()](#U.map) | 数组映射 | array | 📝 中等 |
| [U.forEach()](#U.forEach) | 数组遍历 | void | 📝 中等 |
| [U.find()](#U.find) | 查找元素 | any | 📝 中等 |
| [U.sort()](#U.sort) | 数组排序 | array | 📝 低 |

### ⏰ 时间处理类（4个方法）
| 方法 | 功能 | 返回类型 | 使用频率 |
|------|------|---------|---------|
| [U.formatTime()](#U.formatTime) | 时间格式化 | string | 📊 高 |
| [U.parseTime()](#U.parseTime) | 时间解析 | number | 📝 中等 |
| [U.timeframe()](#U.timeframe) | 时间周期转换 | number | 📝 中等 |
| [U.timestamp()](#U.timestamp) | 时间戳处理 | number | 📝 中等 |

## 🔍 数据验证方法

### U.isValid() - 数据有效性检查

检查数据是否为有效值（非null、undefined、空字符串、空对象）。

#### 语法格式
```javascript
U.isValid(value)
```

#### 参数详解
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `value` | any | ✅ | 待检查的值 |

#### 返回值
返回boolean，true表示有效，false表示无效。

#### 基础示例
```javascript
//@name=数据验证示例
//@position=main
//@version=1

// 基础验证
O.print('有效数字: ' + U.isValid(123))        // true
O.print('有效字符串: ' + U.isValid('hello'))  // true
O.print('null值: ' + U.isValid(null))        // false
O.print('undefined: ' + U.isValid(undefined)) // false
O.print('空字符串: ' + U.isValid(''))         // false
O.print('空数组: ' + U.isValid([]))           // false
O.print('空对象: ' + U.isValid({}))           // false

// 实际应用
period = I.int(20, '周期')
if (U.isValid(dataList) && dataList.length > period) {
    ma = F.ma(dataList, period, 'close')
    
    // 验证计算结果
    validMA = ma.filter(val => U.isValid(val))
    O.print('有效MA数据点: ' + validMA.length)
    
    if (validMA.length > 0) {
        maStyle = S.line('#FF6600', 2, 'solid')
        D.line(ma, maStyle)
        O.tools('MA' + period, ma, maStyle)
    }
} else {
    O.print('数据不足，无法计算MA', 'warn')
}
```

### U.isValidNumber() - 数值有效性检查

检查数值是否为有效数字（非null、undefined、NaN、Infinity）。

#### 语法格式
```javascript
U.isValidNumber(value)
```

#### 完整示例
```javascript
//@name=数值验证与处理
//@position=main
//@version=1

// 参数定义
threshold = I.float(100.0, '价格阈值')

// 获取当前价格
currentKline = dataList[dataList.length - 1]
currentPrice = currentKline ? currentKline.close : null

// 数值验证
if (U.isValidNumber(currentPrice) && U.isValidNumber(threshold)) {
    O.print('当前价格: ' + currentPrice.toFixed(2))
    O.print('设定阈值: ' + threshold.toFixed(2))
    
    // 价格比较
    if (currentPrice > threshold) {
        O.print('价格高于阈值', 'warn')
        O.notify('价格突破阈值！')
    }
    
    // 计算差值（确保是有效数字）
    priceDiff = currentPrice - threshold
    if (U.isValidNumber(priceDiff)) {
        O.print('价格差值: ' + priceDiff.toFixed(2))
    }
} else {
    O.print('价格数据无效', 'error')
}

// 批量验证数组中的数值
prices = F.attr(dataList, 'close')
validPrices = prices.filter(price => U.isValidNumber(price))
O.print(`总价格数据: ${prices.length}, 有效数据: ${validPrices.length}`)
```

## 🧮 数学计算方法

### U.sum() - 数组求和

计算数组中所有有效数值的总和。

#### 语法格式
```javascript
U.sum(array, skipInvalid?)
```

#### 参数详解
| 参数 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| `array` | array | ✅ | - | 数值数组 |
| `skipInvalid` | boolean | ❌ | `true` | 是否跳过无效值 |

#### 示例
```javascript
//@name=数学计算工具示例
//@position=vice
//@version=1

// 获取成交量数据
volumes = F.attr(dataList, 'volume')
validVolumes = volumes.filter(vol => U.isValidNumber(vol))

// 计算总成交量
totalVolume = U.sum(validVolumes)
O.print('总成交量: ' + totalVolume.toFixed(0))

// 计算平均成交量
avgVolume = U.avg(validVolumes)
O.print('平均成交量: ' + avgVolume.toFixed(0))

// 获取成交量统计
maxVolume = U.max(validVolumes)
minVolume = U.min(validVolumes)
O.print('最大成交量: ' + maxVolume.toFixed(0))
O.print('最小成交量: ' + minVolume.toFixed(0))

// 计算价格数据
prices = F.attr(dataList, 'close')
validPrices = prices.filter(price => U.isValidNumber(price))

if (validPrices.length > 0) {
    priceSum = U.sum(validPrices)
    priceAvg = U.avg(validPrices)
    
    O.print('价格总和: ' + priceSum.toFixed(2))
    O.print('价格平均: ' + priceAvg.toFixed(2))
}
```

### U.avg() - 平均值计算

计算数组中所有有效数值的平均值。

#### 语法格式
```javascript
U.avg(array, skipInvalid?)
```

#### 高级示例 - 动态平均线
```javascript
//@name=动态平均线
//@position=main
//@version=1

// 参数定义
lookback = I.int(20, '回看周期', 5, 100)
dynamicAvg = I.bool(true, '启用动态平均')

// 获取价格数据
prices = F.attr(dataList, 'close')

// 计算动态平均线
dynamicMA = prices.map((price, index) => {
    if (!U.isValidNumber(price)) return null
    
    if (dynamicAvg) {
        // 动态周期：根据波动率调整
        const start = Math.max(0, index - lookback)
        const recentPrices = prices.slice(start, index + 1)
        const validPrices = recentPrices.filter(p => U.isValidNumber(p))
        
        if (validPrices.length > 0) {
            return U.avg(validPrices)
        }
    } else {
        // 固定周期
        if (index >= lookback - 1) {
            const periodPrices = prices.slice(index - lookback + 1, index + 1)
            const validPrices = periodPrices.filter(p => U.isValidNumber(p))
            
            if (validPrices.length > 0) {
                return U.avg(validPrices)
            }
        }
    }
    
    return null
})

// 样式和绘制
maStyle = S.line('#FF6600', 2, 'solid', title='动态MA')
D.line(dynamicMA, maStyle)

// 输出
setPrecision('price')
O.tools('动态MA', dynamicMA, maStyle)
```

## 📊 数组处理方法

### U.slice() - 数组切片

从数组中提取指定范围的元素。

#### 语法格式
```javascript
U.slice(array, start, end?)
```

#### 参数详解
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `array` | array | ✅ | 源数组 |
| `start` | number | ✅ | 开始索引 |
| `end` | number | ❌ | 结束索引（不包含） |

#### 示例
```javascript
//@name=数据切片处理
//@position=main
//@version=1

// 参数定义
analysisLength = I.int(100, '分析长度', 10, 500)

// 获取最近的数据进行分析
if (dataList.length > analysisLength) {
    // 获取最近N根K线
    recentData = U.slice(dataList, -analysisLength)  // 获取最后N个元素
    O.print(`分析最近${recentData.length}根K线`)
    
    // 提取价格数据
    recentPrices = U.slice(F.attr(dataList, 'close'), -analysisLength)
    
    // 计算统计信息
    if (recentPrices.length > 0) {
        validPrices = recentPrices.filter(p => U.isValidNumber(p))
        
        if (validPrices.length > 0) {
            avgPrice = U.avg(validPrices)
            maxPrice = U.max(validPrices)
            minPrice = U.min(validPrices)
            
            O.print('近期平均价: ' + avgPrice.toFixed(2))
            O.print('近期最高价: ' + maxPrice.toFixed(2))
            O.print('近期最低价: ' + minPrice.toFixed(2))
        }
    }
} else {
    O.print('数据量不足进行分析', 'warn')
}

// 分段分析示例
segmentSize = 20
segments = []

for (let i = 0; i < dataList.length; i += segmentSize) {
    const segment = U.slice(dataList, i, i + segmentSize)
    if (segment.length === segmentSize) {
        segments.push(segment)
    }
}

O.print(`将数据分为${segments.length}个段进行分析`)
```

### U.filter() - 数组过滤

根据条件过滤数组元素。

#### 语法格式
```javascript
U.filter(array, predicate)
```

#### 参数详解
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `array` | array | ✅ | 源数组 |
| `predicate` | function | ✅ | 过滤条件函数 |

#### 完整示例 - 信号过滤系统
```javascript
//@name=高级信号过滤
//@position=main
//@version=1

// 参数定义
minVolume = I.int(1000, '最小成交量', 0, 10000)
priceFilter = I.bool(true, '启用价格过滤')
volumeFilter = I.bool(true, '启用成交量过滤')

// 计算基础指标
fastMA = F.ma(dataList, 5, 'close')
slowMA = F.ma(dataList, 20, 'close')

// 原始信号
rawBuySignals = F.throughUp(fastMA, slowMA)
rawSellSignals = F.throughDown(fastMA, slowMA)

// 信号过滤
filteredBuySignals = rawBuySignals.map((signal, index) => {
    if (signal === null) return null
    
    // 获取当前K线数据
    const kline = dataList[index]
    if (!kline) return null
    
    // 成交量过滤
    if (volumeFilter && kline.volume < minVolume) {
        return null
    }
    
    // 价格过滤（避免在价格异常时发信号）
    if (priceFilter) {
        const priceChange = Math.abs(kline.close - kline.open) / kline.open
        if (priceChange > 0.1) {  // 超过10%的价格变动
            return null
        }
    }
    
    return signal
})

// 使用U.filter进行进一步过滤
validBuySignals = U.filter(filteredBuySignals, signal => signal !== null)
validSellSignals = U.filter(rawSellSignals, signal => signal !== null)

// 统计信息
O.print(`原始买入信号: ${rawBuySignals.filter(s => s !== null).length}`)
O.print(`过滤后买入信号: ${validBuySignals.length}`)
O.print(`信号过滤率: ${(1 - validBuySignals.length / rawBuySignals.filter(s => s !== null).length) * 100}%`)

// 绘制
fastStyle = S.line('#FF0000', 2, 'solid', title='快线')
slowStyle = S.line('#0000FF', 2, 'solid', title='慢线')
buyStyle = S.shape('arrowUp', '#00FF00', 12, 'lowDown', title='买入')

D.line(fastMA, fastStyle)
D.line(slowMA, slowStyle)
D.shape(filteredBuySignals, buyStyle)

// 输出
setPrecision('price')
O.tools('快线MA5', fastMA, fastStyle)
O.tools('慢线MA20', slowMA, slowStyle)
```

## ⏰ 时间处理方法

### U.formatTime() - 时间格式化

将时间戳格式化为可读字符串。

#### 语法格式
```javascript
U.formatTime(timestamp, format?)
```

#### 参数详解
| 参数 | 类型 | 必填 | 默认值 | 说明 |
|------|------|------|--------|------|
| `timestamp` | number | ✅ | - | 时间戳（毫秒） |
| `format` | string | ❌ | `'YYYY-MM-DD HH:mm:ss'` | 格式字符串 |

#### 格式选项
- `YYYY` - 4位年份
- `MM` - 2位月份
- `DD` - 2位日期
- `HH` - 24小时制小时
- `mm` - 分钟
- `ss` - 秒

#### 示例
```javascript
//@name=时间处理工具
//@position=main
//@version=1

// 获取时间信息
if (dataList.length > 0) {
    const firstKline = dataList[0]
    const lastKline = dataList[dataList.length - 1]
    
    // 格式化时间
    const startTime = U.formatTime(firstKline.timestamp, 'YYYY-MM-DD HH:mm:ss')
    const endTime = U.formatTime(lastKline.timestamp, 'YYYY-MM-DD HH:mm:ss')
    const tradingDate = U.formatTime(lastKline.timestamp, 'YYYY-MM-DD')
    
    // 输出时间信息
    O.print('数据开始时间: ' + startTime)
    O.print('数据结束时间: ' + endTime)
    O.print('交易日期: ' + tradingDate)
    
    // 计算时间跨度
    const timeSpan = lastKline.timestamp - firstKline.timestamp
    const hours = Math.floor(timeSpan / (1000 * 60 * 60))
    const days = Math.floor(hours / 24)
    
    O.print(`数据跨度: ${days}天${hours % 24}小时`)
}

// 在标签中显示时间
showTimeLabels = I.bool(false, '显示时间标签')
if (showTimeLabels) {
    timeLabels = dataList.map((kline, index) => {
        if (index % 50 === 0) {  // 每50根K线显示一次时间
            return U.formatTime(kline.timestamp, 'MM-DD HH:mm')
        }
        return null
    })
    
    labelStyle = S.label('#FFFFFF', 10, 'center', 'bottom')
    labelBg = S.labelbg('rgba(0,0,0,0.7)', 'fill')
    D.label(timeLabels, labelStyle, labelBg)
}
```

### U.timeframe() - 时间周期转换

将时间周期字符串转换为毫秒数。

#### 语法格式
```javascript
U.timeframe(period)
```

#### 参数详解
| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `period` | string | ✅ | 时间周期（如'1m', '1h', '1d'） |

#### 支持的周期格式
- `1m`, `5m`, `15m`, `30m` - 分钟
- `1h`, `2h`, `4h`, `6h`, `12h` - 小时  
- `1d`, `3d`, `7d` - 天
- `1w` - 周
- `1M` - 月

#### 示例
```javascript
//@name=多时间框架分析
//@position=main
//@version=1

// 参数定义
higherTimeframe = I.select('1h', ['15m', '1h', '4h', '1d'], '高级时间框架')

// 时间周期转换
currentTF = U.timeframe(chartPeriod)  // 当前图表周期的毫秒数
higherTF = U.timeframe(higherTimeframe)  // 高级时间框架的毫秒数

O.print(`当前周期: ${chartPeriod} (${currentTF}ms)`)
O.print(`高级周期: ${higherTimeframe} (${higherTF}ms)`)

// 计算周期比例
if (currentTF && higherTF) {
    const ratio = higherTF / currentTF
    O.print(`周期倍数: ${ratio}`)
    
    // 根据比例调整指标参数
    const basePeriod = 20
    const adjustedPeriod = Math.max(1, Math.floor(basePeriod / ratio))
    
    O.print(`调整后的MA周期: ${adjustedPeriod}`)
    
    // 计算并绘制调整后的MA
    ma = F.ma(dataList, adjustedPeriod, 'close')
    maStyle = S.line('#FF6600', 2, 'solid', title=`MA${adjustedPeriod}`)
    D.line(ma, maStyle)
    
    setPrecision('price')
    O.tools(`MA${adjustedPeriod}(${higherTimeframe})`, ma, maStyle)
}
```

## 🚀 工具函数综合应用

### 数据质量检测系统
```javascript
//@name=数据质量检测
//@position=vice
//@version=1

// 数据质量检测函数
function analyzeDataQuality(data) {
    const results = {
        total: data.length,
        valid: 0,
        invalid: 0,
        nullValues: 0,
        duplicates: 0,
        outliers: 0
    }
    
    // 基础验证
    data.forEach(item => {
        if (U.isValid(item)) {
            results.valid++
        } else {
            results.invalid++
            if (U.isNull(item)) {
                results.nullValues++
            }
        }
    })
    
    // 异常值检测（使用四分位数方法）
    const validData = U.filter(data, item => U.isValidNumber(item))
    if (validData.length > 0) {
        const sorted = U.sort([...validData], (a, b) => a - b)
        const q1Index = Math.floor(sorted.length * 0.25)
        const q3Index = Math.floor(sorted.length * 0.75)
        const q1 = sorted[q1Index]
        const q3 = sorted[q3Index]
        const iqr = q3 - q1
        const lowerBound = q1 - 1.5 * iqr
        const upperBound = q3 + 1.5 * iqr
        
        results.outliers = U.filter(validData, val => 
            val < lowerBound || val > upperBound
        ).length
    }
    
    return results
}

// 分析各种数据的质量
const priceData = F.attr(dataList, 'close')
const volumeData = F.attr(dataList, 'volume')

const priceQuality = analyzeDataQuality(priceData)
const volumeQuality = analyzeDataQuality(volumeData)

// 输出分析结果
O.print('=== 价格数据质量分析 ===')
O.print(`总数据点: ${priceQuality.total}`)
O.print(`有效数据: ${priceQuality.valid} (${(priceQuality.valid/priceQuality.total*100).toFixed(1)}%)`)
O.print(`无效数据: ${priceQuality.invalid}`)
O.print(`异常值: ${priceQuality.outliers}`)

O.print('=== 成交量数据质量分析 ===')
O.print(`总数据点: ${volumeQuality.total}`)
O.print(`有效数据: ${volumeQuality.valid} (${(volumeQuality.valid/volumeQuality.total*100).toFixed(1)}%)`)
O.print(`无效数据: ${volumeQuality.invalid}`)
O.print(`异常值: ${volumeQuality.outliers}`)

// 数据质量评分
const priceScore = (priceQuality.valid / priceQuality.total) * 100
const volumeScore = (volumeQuality.valid / volumeQuality.total) * 100
const overallScore = (priceScore + volumeScore) / 2

O.print(`数据质量评分: ${overallScore.toFixed(1)}/100`)

// 根据数据质量决定是否继续计算
if (overallScore > 80) {
    O.notify('数据质量良好，可以进行技术分析', 'success')
} else if (overallScore > 60) {
    O.notify('数据质量一般，建议谨慎分析', 'warning')
} else {
    O.notify('数据质量较差，不建议进行分析', 'error')
}
```

## 💡 最佳实践建议

### 1. 数据验证优先
```javascript
// ✅ 推荐：先验证数据再处理
function safeCalculation(data) {
    if (!U.isValid(data) || !U.isArray(data)) {
        O.print('数据格式错误', 'error')
        return null
    }
    
    const validData = U.filter(data, item => U.isValidNumber(item))
    if (validData.length === 0) {
        O.print('没有有效数据', 'warn')
        return null
    }
    
    return U.avg(validData)
}

// 使用安全计算函数
const prices = F.attr(dataList, 'close')
const avgPrice = safeCalculation(prices)
if (avgPrice !== null) {
    O.print('安全计算的平均价格: ' + avgPrice.toFixed(2))
}
```

### 2. 性能优化
```javascript
// ✅ 推荐：缓存计算结果
const validPrices = U.filter(F.attr(dataList, 'close'), p => U.isValidNumber(p))

// 一次过滤，多次使用
const priceSum = U.sum(validPrices)
const priceAvg = U.avg(validPrices)  
const priceMax = U.max(validPrices)
const priceMin = U.min(validPrices)

// ❌ 避免：重复过滤
// const priceSum = U.sum(U.filter(prices, p => U.isValidNumber(p)))
// const priceAvg = U.avg(U.filter(prices, p => U.isValidNumber(p)))
```

### 3. 错误处理
```javascript
// ✅ 推荐：完整的错误处理
function robustCalculation(data, operation) {
    try {
        if (!U.isValid(data)) {
            throw new Error('无效数据输入')
        }
        
        const result = operation(data)
        
        if (!U.isValidNumber(result)) {
            throw new Error('计算结果无效')
        }
        
        return result
    } catch (error) {
        O.print('计算错误: ' + error.message, 'error')
        return null
    }
}
```

## 🔗 相关内容

- **数据处理**: [F方法详解](05-计算函数方法(F方法).md) - 与U方法配合的计算函数
- **调试输出**: [O方法详解](07-数据输出方法(O方法).md) - 使用O.print()输出U方法结果
- **基础概念**: [基础概念和脚本结构](02-基础概念和脚本结构.md) - JavaScript语法支持
- **实际案例**: [脚本案例库](09-完整脚本案例库.md) - U方法在实际指标中的应用
- **错误处理**: [错误处理指南](10-错误处理和调试指南.md) - U方法常见问题解决

---
**提示**: U方法是开发助手工具库，共26个实用函数覆盖数据验证、数学计算、数组处理、时间处理等常用需求。合理使用U方法能显著提升代码质量和开发效率。