# 错误处理和调试指南

## 📋 调试指南概述

本指南提供GainLab Script开发过程中的**完整错误处理和调试解决方案**，涵盖常见错误类型、调试技巧、预防策略和实用工具，帮助开发者快速定位和解决问题，提升代码质量和开发效率。

### 🎯 指南特点
- 🔍 **系统分类** - 按错误类型和方法分类，便于快速查找
- 🛠️ **实用工具** - 提供调试工具和辅助函数
- 💡 **预防策略** - 从源头避免常见错误
- 📝 **代码示例** - 每个错误都有对应的解决方案

### ⚠️ 使用说明
- **错误定位** - 根据错误信息快速定位问题类型
- **解决方案** - 提供具体的修复代码和方法
- **预防措施** - 学习如何避免类似错误再次发生

## 🚨 错误分类体系

### 🔴 语法错误（Syntax Errors）
脚本解析阶段发现的语法问题，导致脚本无法运行。

### 🟠 运行时错误（Runtime Errors）
脚本运行过程中发生的错误，通常与数据类型或方法调用相关。

### 🟡 逻辑错误（Logic Errors）
脚本能运行但结果不正确，最难发现和调试的错误类型。

### 🔵 性能问题（Performance Issues）
脚本运行缓慢或消耗过多资源的问题。

### 🟢 数据问题（Data Issues）
与数据质量、格式或处理相关的问题。

## 🔴 语法错误处理

### 元数据格式错误

#### 错误现象
```javascript
// ❌ 错误示例
//@name = MA  // 多余空格
//@position main  // 缺少等号
//@version=  // 缺少值
```

#### 解决方案
```javascript
// ✅ 正确格式
//@name=MA
//@position=main
//@version=1

// 完整的元数据模板
//@name=指标名称
//@title=完整标题
//@desc=指标描述
//@position=main  // 或 vice
//@version=1
//@vip=1  // 可选
```

#### 检查清单
- [ ] 每行元数据都以`//@`开头
- [ ] 使用`=`连接键值对，无多余空格
- [ ] @name、@position、@version是必填项
- [ ] @position只能是`main`或`vice`
- [ ] @version当前只支持`1`

### JavaScript语法错误

#### 常见错误1：括号不匹配
```javascript
// ❌ 错误
period = I.int(20, '周期'  // 缺少右括号
ma = F.ma(dataList, period, 'close'])  // 括号不匹配

// ✅ 正确
period = I.int(20, '周期')
ma = F.ma(dataList, period, 'close')
```

#### 常见错误2：分号和逗号错误
```javascript
// ❌ 错误
let a = 1, b = 2;  // GainLab中推荐不使用分号
const obj = {a: 1, b: 2,}  // 尾随逗号可能有问题

// ✅ 正确
let a = 1, b = 2
const obj = {a: 1, b: 2}
```

#### 调试技巧
```javascript
// 使用调试输出检查语法
O.print('语法检查点1')
let value = someCalculation()
O.print('语法检查点2: ' + value)

// 分段注释法定位错误
/*
// 逐段取消注释，定位语法错误位置
period = I.int(20, '周期')
// ma = F.ma(dataList, period, 'close')
// D.line(ma, maStyle)
*/
```

## 🟠 运行时错误处理

### I方法运行时错误

#### 错误1：在I方法中使用变量
```javascript
// ❌ 错误：运行时报错
let defaultPeriod = 20
period = I.int(defaultPeriod, '周期')  // 报错！

// 解决方案
period = I.int(20, '周期')  // ✅ 使用常量

// 调试方法：检查I方法调用
O.print('检查I方法调用')
try {
    period = I.int(20, '周期')
    O.print('I方法调用成功: ' + period)
} catch (e) {
    O.print('I方法错误: ' + e.message, 'error')
}
```

#### 错误2：select方法defaultValue不在options中
```javascript
// ❌ 错误：defaultValue不匹配
source = I.select('CLOSE', SOURCE, '数据源')  // 'CLOSE'不在SOURCE中

// 解决方案和调试
O.print('SOURCE选项: ' + JSON.stringify(SOURCE))
source = I.select('close', SOURCE, '数据源')  // ✅ 'close'在SOURCE中

// 通用检查函数
function validateSelectOptions(defaultValue, options, name) {
    if (options.includes(defaultValue)) {
        O.print(`${name}参数验证通过: ${defaultValue}`)
        return defaultValue
    } else {
        O.print(`${name}参数错误: ${defaultValue} 不在选项 ${JSON.stringify(options)} 中`, 'error')
        return options[0]  // 返回第一个有效选项
    }
}

// 使用示例
const validSource = validateSelectOptions('close', SOURCE, '数据源')
source = I.select(validSource, SOURCE, '数据源')
```

### F方法运行时错误

#### 错误1：参数顺序错误（最常见）
```javascript
// ❌ 错误：参数顺序错误
ma = F.ma(20, dataList, 'close')  // 错误！period在前

// 解决方案和调试
O.print('F方法参数检查')
O.print('dataList类型: ' + typeof dataList)
O.print('dataList长度: ' + (dataList ? dataList.length : 'undefined'))

ma = F.ma(dataList, 20, 'close')  // ✅ 正确顺序

// 参数验证函数
function validateFMethodParams(data, period, attr, methodName) {
    const errors = []
    
    if (!data || !Array.isArray(data)) {
        errors.push(`${methodName}: data参数必须是数组`)
    }
    
    if (typeof period !== 'number' || period < 1) {
        errors.push(`${methodName}: period参数必须是大于0的数字`)
    }
    
    if (attr && typeof attr !== 'string') {
        errors.push(`${methodName}: attr参数必须是字符串`)
    }
    
    if (errors.length > 0) {
        O.print(`${methodName}参数错误:`, 'error')
        errors.forEach(error => O.print('  - ' + error, 'error'))
        return false
    }
    
    O.print(`${methodName}参数验证通过`)
    return true
}

// 使用示例
if (validateFMethodParams(dataList, 20, 'close', 'F.ma')) {
    ma = F.ma(dataList, 20, 'close')
}
```

#### 错误2：数据类型不匹配
```javascript
// ❌ 错误：传入错误数据类型
rsi = F.rsi([1, 2, 3], 14)  // 错误！需要K线数据对象数组

// 解决方案和调试
function validateKLineData(data, methodName) {
    if (!data || !Array.isArray(data)) {
        O.print(`${methodName}: 数据必须是数组`, 'error')
        return false
    }
    
    if (data.length === 0) {
        O.print(`${methodName}: 数据数组不能为空`, 'error')
        return false
    }
    
    // 检查K线数据结构
    const firstItem = data[0]
    const requiredProps = ['open', 'high', 'low', 'close']
    const missingProps = requiredProps.filter(prop => !(prop in firstItem))
    
    if (missingProps.length > 0) {
        O.print(`${methodName}: K线数据缺少属性: ${missingProps.join(', ')}`, 'error')
        return false
    }
    
    O.print(`${methodName}: K线数据验证通过，共${data.length}条记录`)
    return true
}

// 使用示例
if (validateKLineData(dataList, 'F.rsi')) {
    rsi = F.rsi(dataList, 14)  // ✅ 正确
} else {
    O.print('无法计算RSI，数据格式错误', 'error')
}
```

### D方法运行时错误

#### 错误1：样式对象未定义
```javascript
// ❌ 错误：样式未定义
D.line(ma, undefined)  // 报错！

// 解决方案和调试
function validateStyle(style, methodName) {
    if (!style) {
        O.print(`${methodName}: 样式对象不能为空`, 'error')
        return false
    }
    
    if (typeof style !== 'object' && typeof style !== 'function') {
        O.print(`${methodName}: 样式必须是对象或函数`, 'error')
        return false
    }
    
    // 如果是样式对象，检查必要属性
    if (typeof style === 'object' && !style.color) {
        O.print(`${methodName}: 样式对象缺少color属性`, 'warn')
    }
    
    return true
}

// 安全绘图函数
function safeDraw(method, data, style, methodName) {
    if (!validateStyle(style, methodName)) {
        // 创建默认样式
        const defaultStyle = S.line('#FF6600', 2, 'solid')
        O.print(`使用默认样式: ${methodName}`)
        return method(data, defaultStyle)
    }
    
    return method(data, style)
}

// 使用示例
ma = F.ma(dataList, 20, 'close')
maStyle = S.line('#FF6600', 2, 'solid')  // ✅ 确保样式已定义
safeDraw(D.line, ma, maStyle, 'D.line')
```

#### 错误2：数据长度不匹配
```javascript
// ❌ 错误：数据长度与dataList不匹配
shortData = [1, 2, 3]  // 只有3个元素
D.line(shortData, maStyle)  // 可能显示异常

// 解决方案和调试
function validateDataLength(data, referenceName, methodName) {
    if (!dataList) {
        O.print(`${methodName}: 无法获取参考数据长度`, 'error')
        return false
    }
    
    const referenceLength = dataList.length
    const dataLength = data ? data.length : 0
    
    O.print(`${methodName}数据长度检查:`)
    O.print(`  参考长度(${referenceName}): ${referenceLength}`)
    O.print(`  数据长度: ${dataLength}`)
    
    if (dataLength !== referenceLength) {
        O.print(`  警告: 长度不匹配，可能影响显示效果`, 'warn')
        
        // 自动修复：填充或裁剪数据
        if (dataLength < referenceLength) {
            const paddedData = [...data]
            while (paddedData.length < referenceLength) {
                paddedData.unshift(null)  // 在开头填充null
            }
            O.print(`  已自动填充到${paddedData.length}个元素`)
            return paddedData
        }
    }
    
    return data
}

// 使用示例
ma = F.ma(dataList, 20, 'close')
const validatedMA = validateDataLength(ma, 'dataList', 'MA显示')
D.line(validatedMA, maStyle)
```

## 🟡 逻辑错误调试

### 计算逻辑错误调试

#### 分段验证技术
```javascript
//@name=逻辑调试示例
//@position=main
//@version=1

// 启用调试模式
const DEBUG_MODE = I.bool(true, '调试模式')

function debugPrint(message, data) {
    if (DEBUG_MODE) {
        if (data !== undefined) {
            O.print(`[DEBUG] ${message}: ${JSON.stringify(data)}`)
        } else {
            O.print(`[DEBUG] ${message}`)
        }
    }
}

// 分段验证MACD计算
debugPrint('开始MACD计算')

// 第1步：验证输入参数
const fastPeriod = 12
const slowPeriod = 26  
const signalPeriod = 9

debugPrint('参数验证', {fastPeriod, slowPeriod, signalPeriod})

// 第2步：验证数据
debugPrint('数据验证', {
    dataListLength: dataList.length,
    firstKline: dataList[0],
    lastKline: dataList[dataList.length - 1]
})

// 第3步：计算EMA并验证
const ema12 = F.ema(dataList, fastPeriod, 'close')
const ema26 = F.ema(dataList, slowPeriod, 'close')

debugPrint('EMA计算结果', {
    ema12_length: ema12.length,
    ema12_first_valid: ema12.find(v => v !== null),
    ema26_last: ema26[ema26.length - 1]
})

// 第4步：验证DIF计算
const dif = ema12.map((fast, i) => {
    if (fast !== null && ema26[i] !== null) {
        return fast - ema26[i]
    }
    return null
})

debugPrint('DIF计算验证', {
    dif_length: dif.length,
    dif_valid_count: dif.filter(v => v !== null).length,
    dif_last_5: dif.slice(-5)
})

// 第5步：完整MACD验证
const macdResult = F.macd(dataList, fastPeriod, slowPeriod, signalPeriod)
const officialDIF = F.attr(macdResult, 'dif')

// 对比手动计算和官方函数结果
let diffCount = 0
dif.forEach((manual, i) => {
    const official = officialDIF[i]
    if (manual !== null && official !== null) {
        const diff = Math.abs(manual - official)
        if (diff > 0.0001) {  // 容差
            diffCount++
        }
    }
})

debugPrint('计算验证结果', {
    manual_vs_official_diff_count: diffCount,
    calculation_accuracy: diffCount === 0 ? '精确' : '存在差异'
})
```

### 条件逻辑错误调试

#### 信号检测逻辑验证
```javascript
// 信号检测逻辑调试
function debugSignalLogic() {
    const fastMA = F.ma(dataList, 5, 'close')
    const slowMA = F.ma(dataList, 20, 'close')
    
    // 手动实现交叉检测用于对比
    let manualBuySignals = []
    let manualSellSignals = []
    
    for (let i = 1; i < fastMA.length; i++) {
        const prevFast = fastMA[i - 1]
        const currFast = fastMA[i]
        const prevSlow = slowMA[i - 1]
        const currSlow = slowMA[i]
        
        if (prevFast !== null && currFast !== null && 
            prevSlow !== null && currSlow !== null) {
            
            // 金叉检测
            if (prevFast <= prevSlow && currFast > currSlow) {
                manualBuySignals[i] = {val1: currFast, val2: currSlow}
                if (DEBUG_MODE) {
                    O.print(`手动金叉检测[${i}]: ${currFast.toFixed(4)} > ${currSlow.toFixed(4)}`)
                }
            } else {
                manualBuySignals[i] = null
            }
            
            // 死叉检测
            if (prevFast >= prevSlow && currFast < currSlow) {
                manualSellSignals[i] = {val1: currFast, val2: currSlow}
                if (DEBUG_MODE) {
                    O.print(`手动死叉检测[${i}]: ${currFast.toFixed(4)} < ${currSlow.toFixed(4)}`)
                }
            } else {
                manualSellSignals[i] = null
            }
        } else {
            manualBuySignals[i] = null
            manualSellSignals[i] = null
        }
    }
    
    // 使用官方函数对比
    const officialBuy = F.throughUp(fastMA, slowMA)
    const officialSell = F.throughDown(fastMA, slowMA)
    
    // 对比结果
    const manualBuyCount = manualBuySignals.filter(s => s !== null).length
    const officialBuyCount = officialBuy.filter(s => s !== null).length
    
    debugPrint('信号检测对比', {
        manual_buy_signals: manualBuyCount,
        official_buy_signals: officialBuyCount,
        logic_consistent: manualBuyCount === officialBuyCount
    })
    
    return {
        manualBuy: manualBuySignals,
        officialBuy: officialBuy,
        consistent: manualBuyCount === officialBuyCount
    }
}

// 执行逻辑验证
if (DEBUG_MODE) {
    const logicTest = debugSignalLogic()
    if (!logicTest.consistent) {
        O.print('警告: 信号逻辑存在不一致', 'error')
    }
}
```

## 🔵 性能问题诊断

### 性能监控工具

#### 计算时间监控
```javascript
// 性能监控工具
function performanceMonitor(name, fn) {
    const startTime = Date.now()
    const result = fn()
    const endTime = Date.now()
    const duration = endTime - startTime
    
    O.print(`[性能] ${name}: ${duration}ms`)
    
    if (duration > 100) {  // 超过100ms警告
        O.print(`[性能警告] ${name} 执行时间过长: ${duration}ms`, 'warn')
    }
    
    return result
}

// 使用示例
const ma = performanceMonitor('MA计算', () => {
    return F.ma(dataList, 20, 'close')
})

const rsi = performanceMonitor('RSI计算', () => {
    return F.rsi(dataList, 14)
})
```

#### 重复计算检测
```javascript
// 重复计算检测工具
const calculationCache = new Map()

function cachedCalculation(key, calculator) {
    if (calculationCache.has(key)) {
        O.print(`[缓存命中] 使用缓存结果: ${key}`)
        return calculationCache.get(key)
    }
    
    O.print(`[计算] 执行新计算: ${key}`)
    const result = calculator()
    calculationCache.set(key, result)
    return result
}

// 使用示例：避免重复计算相同的MA
const ma20_1 = cachedCalculation('MA_20_close', () => F.ma(dataList, 20, 'close'))
const ma20_2 = cachedCalculation('MA_20_close', () => F.ma(dataList, 20, 'close'))  // 使用缓存

// 内存使用监控
function memoryUsageCheck(label) {
    // 简化的内存检查
    const objectCount = Object.keys(window).length
    O.print(`[内存] ${label}: 全局对象数量 ${objectCount}`)
}

memoryUsageCheck('计算开始')
// ... 执行计算
memoryUsageCheck('计算结束')
```

### 大数据处理优化

#### 数据分片处理
```javascript
// 大数据分片处理
function processLargeData(data, processor, chunkSize = 1000) {
    if (data.length <= chunkSize) {
        return processor(data)
    }
    
    O.print(`[优化] 大数据分片处理: ${data.length} 条记录，分 ${Math.ceil(data.length / chunkSize)} 批`)
    
    const results = []
    
    for (let i = 0; i < data.length; i += chunkSize) {
        const chunk = data.slice(i, i + chunkSize)
        const chunkResult = processor(chunk)
        results.push(...chunkResult)
        
        O.print(`[优化] 处理进度: ${Math.min(i + chunkSize, data.length)}/${data.length}`)
    }
    
    return results
}

// 使用示例
const largeDataResult = processLargeData(dataList, (chunk) => {
    return F.ma(chunk, 20, 'close')
}, 500)
```

## 🟢 数据问题处理

### 数据质量检查

#### 完整数据质量检查工具
```javascript
// 数据质量综合检查
function comprehensiveDataCheck(data, label = 'Unknown') {
    const report = {
        label: label,
        totalRecords: data.length,
        validRecords: 0,
        nullRecords: 0,
        invalidRecords: 0,
        duplicates: 0,
        outliers: 0,
        dateGaps: 0,
        issues: []
    }
    
    O.print(`=== ${label} 数据质量检查 ===`)
    
    // 基础数据检查
    data.forEach((item, index) => {
        if (item === null || item === undefined) {
            report.nullRecords++
            report.issues.push(`记录${index}: null/undefined`)
        } else if (typeof item === 'object' && item.close !== undefined) {
            // K线数据检查
            if (U.isValidNumber(item.close) && U.isValidNumber(item.open) && 
                U.isValidNumber(item.high) && U.isValidNumber(item.low)) {
                
                // 数据合理性检查
                if (item.high < item.low) {
                    report.invalidRecords++
                    report.issues.push(`记录${index}: 最高价 < 最低价`)
                } else if (item.close > item.high || item.close < item.low) {
                    report.invalidRecords++
                    report.issues.push(`记录${index}: 收盘价超出高低价范围`)
                } else {
                    report.validRecords++
                }
            } else {
                report.invalidRecords++
                report.issues.push(`记录${index}: 价格数据无效`)
            }
        } else if (U.isValidNumber(item)) {
            report.validRecords++
        } else {
            report.invalidRecords++
            report.issues.push(`记录${index}: 数据类型无效`)
        }
    })
    
    // 重复数据检查（简化版）
    if (data.length > 1 && typeof data[0] === 'object') {
        const timestamps = data.map(item => item.timestamp).filter(t => t)
        const uniqueTimestamps = [...new Set(timestamps)]
        report.duplicates = timestamps.length - uniqueTimestamps.length
    }
    
    // 输出报告
    O.print(`总记录数: ${report.totalRecords}`)
    O.print(`有效记录: ${report.validRecords} (${(report.validRecords/report.totalRecords*100).toFixed(1)}%)`)
    O.print(`无效记录: ${report.invalidRecords}`)
    O.print(`空记录: ${report.nullRecords}`)
    O.print(`重复记录: ${report.duplicates}`)
    
    // 质量评分
    const qualityScore = report.validRecords / report.totalRecords * 100
    let qualityLevel = '优秀'
    if (qualityScore < 90) qualityLevel = '良好'
    if (qualityScore < 80) qualityLevel = '一般'  
    if (qualityScore < 70) qualityLevel = '较差'
    
    O.print(`数据质量: ${qualityLevel} (${qualityScore.toFixed(1)}%)`)
    
    // 显示前5个问题
    if (report.issues.length > 0) {
        O.print('主要问题:')
        report.issues.slice(0, 5).forEach(issue => O.print(`  - ${issue}`))
        if (report.issues.length > 5) {
            O.print(`  ... 还有 ${report.issues.length - 5} 个问题`)
        }
    }
    
    return report
}

// 使用示例
const dataQualityReport = comprehensiveDataCheck(dataList, 'K线数据')

// 根据数据质量决定处理策略
if (dataQualityReport.validRecords / dataQualityReport.totalRecords < 0.8) {
    O.notify('数据质量较差，建议检查数据源', 'warning')
}
```

### 数据修复工具

#### 自动数据修复
```javascript
// 数据自动修复工具
function autoFixData(data, options = {}) {
    const fixedData = [...data]  // 创建副本
    let fixCount = 0
    
    const defaults = {
        fillNull: true,
        fixPriceLogic: true, 
        removeOutliers: false,
        smoothGaps: true
    }
    
    const config = {...defaults, ...options}
    
    O.print('[数据修复] 开始自动修复数据')
    
    for (let i = 0; i < fixedData.length; i++) {
        const item = fixedData[i]
        
        // 修复null值
        if (config.fillNull && (item === null || item === undefined)) {
            // 用前后有效值的平均值填充
            let prevValid = null
            let nextValid = null
            
            // 找前面的有效值
            for (let j = i - 1; j >= 0; j--) {
                if (fixedData[j] && U.isValidNumber(fixedData[j].close || fixedData[j])) {
                    prevValid = fixedData[j]
                    break
                }
            }
            
            // 找后面的有效值  
            for (let j = i + 1; j < fixedData.length; j++) {
                if (fixedData[j] && U.isValidNumber(fixedData[j].close || fixedData[j])) {
                    nextValid = fixedData[j]
                    break
                }
            }
            
            if (prevValid && nextValid) {
                if (typeof prevValid === 'object') {
                    fixedData[i] = {
                        timestamp: prevValid.timestamp + (nextValid.timestamp - prevValid.timestamp) / 2,
                        open: (prevValid.close + nextValid.open) / 2,
                        high: Math.max(prevValid.close, nextValid.open),
                        low: Math.min(prevValid.close, nextValid.open),
                        close: (prevValid.close + nextValid.close) / 2,
                        volume: (prevValid.volume + nextValid.volume) / 2
                    }
                } else {
                    fixedData[i] = (prevValid + nextValid) / 2
                }
                fixCount++
            }
        }
        
        // 修复K线价格逻辑错误
        if (config.fixPriceLogic && item && typeof item === 'object') {
            if (item.high < item.low) {
                // 交换高低价
                const temp = item.high
                item.high = item.low
                item.low = temp
                fixCount++
                O.print(`[修复] 记录${i}: 修正高低价错误`)
            }
            
            if (item.close > item.high) {
                item.high = item.close
                fixCount++
            }
            
            if (item.close < item.low) {
                item.low = item.close
                fixCount++
            }
        }
    }
    
    O.print(`[数据修复] 完成，修复${fixCount}处问题`)
    return fixedData
}

// 使用示例
const cleanedData = autoFixData(dataList, {
    fillNull: true,
    fixPriceLogic: true,
    removeOutliers: false
})

// 对比修复前后
const beforeQuality = comprehensiveDataCheck(dataList, '修复前')
const afterQuality = comprehensiveDataCheck(cleanedData, '修复后')

O.print(`数据修复效果: ${beforeQuality.validRecords} -> ${afterQuality.validRecords} 有效记录`)
```

## 🛠️ 调试工具集

### 调试辅助函数库

```javascript
// GainLab Script 调试工具库
const DebugTools = {
    // 启用/禁用调试
    enabled: I.bool(false, '启用调试', '调试设置', '启用详细调试输出'),
    
    // 调试输出
    log: function(message, level = 'info') {
        if (!this.enabled) return
        
        const timestamp = U.formatTime(Date.now(), 'HH:mm:ss')
        const prefix = `[${timestamp}][${level.toUpperCase()}]`
        
        switch(level) {
            case 'error':
                O.print(`${prefix} ${message}`, 'error')
                break
            case 'warn':
                O.print(`${prefix} ${message}`, 'warn')
                break
            default:
                O.print(`${prefix} ${message}`)
        }
    },
    
    // 数据检查
    inspect: function(data, name = 'Data') {
        if (!this.enabled) return
        
        this.log(`=== ${name} 检查 ===`)
        this.log(`类型: ${typeof data}`)
        
        if (Array.isArray(data)) {
            this.log(`数组长度: ${data.length}`)
            this.log(`首元素: ${JSON.stringify(data[0])}`)
            this.log(`末元素: ${JSON.stringify(data[data.length - 1])}`)
            
            const validCount = data.filter(item => 
                item !== null && item !== undefined
            ).length
            this.log(`有效元素: ${validCount}/${data.length}`)
        } else if (typeof data === 'object' && data !== null) {
            this.log(`对象属性: ${Object.keys(data).join(', ')}`)
        } else {
            this.log(`值: ${data}`)
        }
    },
    
    // 性能计时
    time: function(label) {
        if (!this.enabled) return
        this._timers = this._timers || {}
        this._timers[label] = Date.now()
        this.log(`⏱️ 开始计时: ${label}`)
    },
    
    timeEnd: function(label) {
        if (!this.enabled) return
        if (!this._timers || !this._timers[label]) {
            this.log(`⚠️ 未找到计时器: ${label}`, 'warn')
            return
        }
        
        const duration = Date.now() - this._timers[label]
        this.log(`⏱️ ${label}: ${duration}ms`)
        delete this._timers[label]
        
        if (duration > 100) {
            this.log(`⚠️ 性能警告: ${label} 耗时${duration}ms`, 'warn')
        }
    },
    
    // 方法调用跟踪
    trace: function(methodName, params) {
        if (!this.enabled) return
        this.log(`🔍 调用: ${methodName}(${JSON.stringify(params)})`)
    },
    
    // 断言检查
    assert: function(condition, message) {
        if (!condition) {
            this.log(`❌ 断言失败: ${message}`, 'error')
            O.notify('断言失败: ' + message, 'error')
        } else if (this.enabled) {
            this.log(`✅ 断言通过: ${message}`)
        }
    }
}

// 使用示例
DebugTools.log('脚本开始执行')

DebugTools.time('MA计算')
const ma = F.ma(dataList, 20, 'close')
DebugTools.timeEnd('MA计算')

DebugTools.inspect(ma, 'MA结果')
DebugTools.assert(ma.length === dataList.length, 'MA数据长度匹配')

DebugTools.trace('F.rsi', {dataList: 'K线数据', period: 14})
const rsi = F.rsi(dataList, 14)

DebugTools.assert(
    rsi.filter(v => v !== null && (v < 0 || v > 100)).length === 0,
    'RSI值在0-100范围内'
)
```

## 💡 错误预防策略

### 代码模板和最佳实践

#### 健壮的脚本模板
```javascript
//@name=健壮脚本模板
//@title=Robust Script Template 健壮脚本模板
//@desc=包含完整错误处理和验证的脚本模板
//@position=main
//@version=1

try {
    // === 1. 参数验证 ===
    const period = I.int(20, '周期', 1, 200)
    const source = I.select('close', SOURCE, '数据源')
    
    // 验证参数有效性
    if (!U.isValidNumber(period) || period < 1) {
        throw new Error('周期参数无效')
    }
    
    if (!SOURCE.includes(source)) {
        throw new Error('数据源参数无效')
    }
    
    // === 2. 数据验证 ===
    if (!dataList || !Array.isArray(dataList) || dataList.length === 0) {
        throw new Error('K线数据无效或为空')
    }
    
    if (dataList.length < period) {
        O.notify(`数据不足：需要${period}条，仅有${dataList.length}条`, 'warning')
        return  // 提前退出
    }
    
    // === 3. 安全计算 ===
    let ma = null
    try {
        ma = F.ma(dataList, period, source)
        if (!ma || ma.length === 0) {
            throw new Error('MA计算失败')
        }
    } catch (calcError) {
        O.print('计算错误: ' + calcError.message, 'error')
        return
    }
    
    // === 4. 数据后处理验证 ===
    const validMACount = ma.filter(v => U.isValidNumber(v)).length
    if (validMACount === 0) {
        O.print('警告: MA计算结果全为无效值', 'warn')
        return
    }
    
    // === 5. 安全绘图 ===
    const maStyle = S.line('#FF6600', 2, 'solid', title='MA线')
    
    try {
        D.line(ma, maStyle)
    } catch (drawError) {
        O.print('绘图错误: ' + drawError.message, 'error')
        // 尝试使用默认样式
        D.line(ma, S.line('#999999', 1, 'solid'))
    }
    
    // === 6. 输出设置 ===
    setPrecision('price')
    O.tools(`MA${period}`, ma, maStyle)
    
    // === 7. 状态报告 ===
    O.print(`✅ 脚本执行成功`)
    O.print(`📊 MA${period}计算完成，有效数据: ${validMACount}/${ma.length}`)
    
} catch (error) {
    // === 全局错误处理 ===
    O.print(`❌ 脚本执行失败: ${error.message}`, 'error')
    O.notify('脚本执行出错，请检查参数和数据', 'error')
    
    // 提供基本信息帮助诊断
    O.print(`诊断信息:`, 'info')
    O.print(`  dataList长度: ${dataList ? dataList.length : 'undefined'}`)
    O.print(`  chartSymbol: ${chartSymbol || 'undefined'}`)
    O.print(`  chartPeriod: ${chartPeriod || 'undefined'}`)
}
```

### 测试驱动开发

#### 单元测试思路
```javascript
// 伪单元测试框架（用于开发阶段验证）
const TestFramework = {
    tests: [],
    results: {passed: 0, failed: 0, total: 0},
    
    test: function(name, testFunction) {
        this.tests.push({name, testFunction})
    },
    
    run: function() {
        O.print('=== 开始运行测试 ===')
        
        this.tests.forEach(test => {
            try {
                test.testFunction()
                this.results.passed++
                O.print(`✅ ${test.name}`)
            } catch (error) {
                this.results.failed++
                O.print(`❌ ${test.name}: ${error.message}`, 'error')
            }
            this.results.total++
        })
        
        O.print(`=== 测试结果 ===`)
        O.print(`通过: ${this.results.passed}`)
        O.print(`失败: ${this.results.failed}`)
        O.print(`总计: ${this.results.total}`)
        O.print(`成功率: ${(this.results.passed / this.results.total * 100).toFixed(1)}%`)
    }
}

// 编写测试用例
TestFramework.test('dataList应该是数组', () => {
    if (!Array.isArray(dataList)) {
        throw new Error('dataList不是数组')
    }
})

TestFramework.test('dataList应该不为空', () => {
    if (dataList.length === 0) {
        throw new Error('dataList为空')
    }
})

TestFramework.test('K线数据应该有必要字段', () => {
    const firstKline = dataList[0]
    const requiredFields = ['open', 'high', 'low', 'close']
    
    requiredFields.forEach(field => {
        if (!(field in firstKline)) {
            throw new Error(`缺少字段: ${field}`)
        }
    })
})

TestFramework.test('MA计算应该返回正确长度', () => {
    const ma = F.ma(dataList, 5, 'close')
    if (ma.length !== dataList.length) {
        throw new Error(`MA长度不匹配: 期望${dataList.length}, 实际${ma.length}`)
    }
})

// 运行测试（仅在开发模式下）
if (I.bool(false, '运行测试', '开发设置')) {
    TestFramework.run()
}
```

## 🔗 相关内容

- **基础规则**: [重要规则汇总](01-重要规则汇总.md) - 了解核心约束避免错误
- **方法详解**: [各方法详解](00-主索引.md#方法分类) - 深入学习正确用法
- **实际案例**: [脚本案例库](09-完整脚本案例库.md) - 参考正确的代码实现
- **最佳实践**: [高级主题和最佳实践](11-高级主题和最佳实践.md) - 提升代码质量

---
**提示**: 良好的错误处理和调试习惯是开发高质量GainLab Script的关键。建议在开发过程中主动使用这些调试工具和技巧，从源头预防错误的发生。